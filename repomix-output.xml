This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
src/
  commands/
    index.ts
  components/
    alias/
      AliasManager.tsx
    auth/
      AuthManager.tsx
    common/
      Badge.tsx
      Box.tsx
      Button.tsx
      Card.tsx
      Collapsible.tsx
      ConfirmDialog.tsx
      Divider.tsx
      ErrorBoundary.tsx
      ErrorNotification.tsx
      ErrorProvider.tsx
      index.ts
      Modal.tsx
      Notification.tsx
      ProgressBar.tsx
      Spinner.tsx
      Table.tsx
      Tabs.tsx
      TextInput.tsx
      Tooltip.tsx
      TreeView.tsx
    metadata/
      MetadataTools.tsx
    org/
      OrgManager.tsx
    plugins/
      PluginsPanel.tsx
    project/
      ProjectGenerator.tsx
    run/
      RunTools.tsx
    MainMenu.tsx
  config/
    index.ts
  hooks/
    index.ts
    useMeasure.ts
    useNodeSelection.ts
  themes/
    index.ts
  types/
    ink-components.d.ts
    theme.ts
  utils/
    errorReporter.ts
    helpers.ts
    index.ts
    logger.ts
  index.ts
tests/
  utils/
    errorReporter.test.ts
    logger.test.ts
.gitignore
CLAUDE.md
package.json
README.md
tsconfig.json
tsup.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(gh pr list:*)",
      "Bash(find:*)",
      "Bash(npm install:*)",
      "Bash(cat:*)",
      "Bash(npm view:*)",
      "Bash(npm run build:*)",
      "Bash(npx tsc:*)",
      "Bash(ls:*)",
      "Bash(mkdir:*)"
    ],
    "deny": []
  }
}
</file>

<file path="src/commands/index.ts">
import { Command, Flags } from '@oclif/core';
import { render, Text } from 'ink';
import * as React from 'react';
import { MainMenu } from '../components/MainMenu';

export default class SFTUI extends Command {
  static description = 'Salesforce TUI - An interactive terminal UI for Salesforce CLI';

  static examples = [
    `$ sft`, // Default command
    `$ sft --help`,
    `$ sft --version`,
  ];

  static flags = {
    version: Flags.boolean({
      char: 'v',
      description: 'Show version',
      required: false,
    }),
    help: Flags.help({ char: 'h' }),
    debug: Flags.boolean({
      description: 'Enable debug mode',
      default: false,
    }),
  };

  async run() {
    const { flags } = await this.parse(SFTUI);

    if (flags.version) {
      this.log(`SF TUI v${this.config.version}`);
      return;
    }

    // Render the main menu
    render(
      React.createElement(MainMenu)
    );
  }
}
</file>

<file path="src/components/alias/AliasManager.tsx">
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import { TextInput } from '../common/TextInput';

type Alias = {
  alias: string;
  value: string;
};

type AliasManagerProps = {
  onBack: () => void;
};

export const AliasManager = ({ onBack }: AliasManagerProps) => {
  const [aliases, setAliases] = useState<Alias[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [output, setOutput] = useState('');
  const [selectedAlias, setSelectedAlias] = useState<Alias | null>(null);
  const [view, setView] = useState<'list' | 'add' | 'edit' | 'delete' | 'info'>('list');
  const [newAlias, setNewAlias] = useState('');
  const [aliasValue, setAliasValue] = useState('');

  // Load aliases on component mount
  useEffect(() => {
    loadAliases();
  }, []);

  const loadAliases = async () => {
    try {
      setIsLoading(true);
      setError('');
      
      // Run sf alias list command
      const { stdout } = await execa('sf', ['alias', 'list', '--json']);
      const result = JSON.parse(stdout);
      
      if (result.status === 0 && result.result) {
        // Convert the result to an array of aliases
        const aliasList = Object.entries(result.result).map(([alias, value]) => ({
          alias,
          value: String(value)
        }));
        
        setAliases(aliasList);
      } else {
        setAliases([]);
      }
    } catch (err) {
      setError(`Failed to load aliases: ${err instanceof Error ? err.message : String(err)}`);
      setAliases([]);
    } finally {
      setIsLoading(false);
    }
  };

  const runCommand = async (command: string, args: string[] = []) => {
    try {
      setOutput('');
      
      const process = execa('sf', [command, ...args]);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      // Refresh aliases after command completes
      await loadAliases();
      return true;
    } catch (err) {
      setOutput(`Error: ${err instanceof Error ? err.message : String(err)}`);
      return false;
    }
  };

  const handleAddAlias = async () => {
    if (!newAlias || !aliasValue) {
      setError('Both alias name and value are required');
      return;
    }
    
    const success = await runCommand('alias', ['set', newAlias, aliasValue]);
    if (success) {
      setNewAlias('');
      setAliasValue('');
      setView('list');
    }
  };

  const handleDeleteAlias = async (alias: string) => {
    const success = await runCommand('alias', ['unset', alias]);
    if (success) {
      setSelectedAlias(null);
      setView('list');
    }
  };

  useInput((input, key) => {
    if (key.escape) {
      if (view !== 'list') {
        setView('list');
        setSelectedAlias(null);
      } else {
        onBack();
      }
    }
  });

  const renderList = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Your Salesforce CLI Aliases</Text>
      </Box>
      
      {isLoading ? (
        <Box>
          <Text><Spinner type="dots" /> Loading aliases...</Text>
        </Box>
      ) : error ? (
        <Text color="red">Error: {error}</Text>
      ) : aliases.length === 0 ? (
        <Text>No aliases found. Create one to get started.</Text>
      ) : (
        <Box flexDirection="column">
          <Box marginBottom={1}>
            <SelectInput
              items={[
                ...aliases.map(alias => ({
                  label: `${alias.alias} = ${alias.value}`,
                  value: alias.alias,
                  alias
                })),
                { label: '➕ Add New Alias', value: 'add' }
              ]}
              onSelect={(item) => {
                if (item.value === 'add') {
                  setView('add');
                } else {
                  setSelectedAlias((item as any).alias);
                  setView('info');
                }
              }}
              itemComponent={({ isSelected, label }) => (
                <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
              )}
            />
          </Box>
        </Box>
      )}
      
      <Box marginTop={1}>
        <Text>Press ESC to go back</Text>
      </Box>
    </Box>
  );

  const renderAddForm = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Add New Alias</Text>
      </Box>
      
      <Box marginBottom={1} flexDirection="column">
        <Box marginBottom={1}>
          <Text>Alias Name: </Text>
          <TextInput
            value={newAlias}
            onChange={setNewAlias}
            placeholder="my-alias"
          />
        </Box>
        
        <Box marginBottom={2}>
          <Text>Alias Value: </Text>
          <TextInput
            value={aliasValue}
            onChange={setAliasValue}
            placeholder="user@example.com or 00D..."
          />
        </Box>
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              { label: 'Create Alias', value: 'create' },
              { label: 'Cancel', value: 'cancel' },
            ]}
            onSelect={(item) => {
              if (item.value === 'create') {
                handleAddAlias();
              } else {
                setView('list');
              }
            }}
          />
        </Box>
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderAliasInfo = () => {
    if (!selectedAlias) return null;
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Alias: {selectedAlias.alias}</Text>
        </Box>
        
        <Box marginBottom={2}>
          <Text>Value: {selectedAlias.value}</Text>
        </Box>
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              { label: 'Edit Alias', value: 'edit' },
              { label: 'Delete Alias', value: 'delete' },
              { label: 'Back to List', value: 'back' },
            ]}
            onSelect={(item) => {
              switch (item.value) {
                case 'edit':
                  setNewAlias(selectedAlias.alias);
                  setAliasValue(selectedAlias.value);
                  setView('edit');
                  break;
                case 'delete':
                  setView('delete');
                  break;
                case 'back':
                  setView('list');
                  setSelectedAlias(null);
                  break;
              }
            }}
          />
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  const renderDeleteConfirmation = () => {
    if (!selectedAlias) return null;
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Delete Alias</Text>
        </Box>
        
        <Box marginBottom={2}>
          <Text>Are you sure you want to delete the alias '{selectedAlias.alias}'?</Text>
          <Text>Value: {selectedAlias.value}</Text>
        </Box>
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              { label: '✅ Yes, delete it', value: 'confirm' },
              { label: '❌ No, keep it', value: 'cancel' },
            ]}
            onSelect={(item) => {
              if (item.value === 'confirm') {
                handleDeleteAlias(selectedAlias.alias);
              } else {
                setView('info');
              }
            }}
          />
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  return (
    <Box flexDirection="column" padding={1}>
      <Box marginBottom={1}>
        <Text bold>Salesforce CLI Alias Manager</Text>
      </Box>
      
      {view === 'list' && renderList()}
      {view === 'add' && renderAddForm()}
      {view === 'info' && renderAliasInfo()}
      {view === 'delete' && renderDeleteConfirmation()}
      
      {output && (
        <Box marginTop={1} borderStyle="round" padding={1}>
          <Text>{output}</Text>
        </Box>
      )}
      
      {error && (
        <Box marginTop={1}>
          <Text color="red">{error}</Text>
        </Box>
      )}
    </Box>
  );
};

export default AliasManager;
</file>

<file path="src/components/auth/AuthManager.tsx">
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import open from 'open';
import { TextInput } from '../common/TextInput';

type AuthManagerProps = {
  onBack: () => void;
};

type AuthMethod = 'web' | 'jwt' | 'device' | 'token' | 'soap';

const AUTH_METHODS = [
  {
    label: 'Web Login (Recommended)',
    value: 'web',
    description: 'Opens a browser window to log in to your org',
    requiresInput: false,
  },
  {
    label: 'JWT Bearer Flow',
    value: 'jwt',
    description: 'Authenticate using a JWT bearer token',
    requiresInput: true,
  },
  {
    label: 'Device Code Flow',
    value: 'device',
    description: 'Authenticate using a device code',
    requiresInput: false,
  },
  {
    label: 'Access Token',
    value: 'token',
    description: 'Authenticate with an existing access token',
    requiresInput: true,
  },
  {
    label: 'SOAP Username-Password',
    value: 'soap',
    description: 'Authenticate with username and password (not recommended)',
    requiresInput: true,
  },
];

export const AuthManager = ({ onBack }: AuthManagerProps) => {
  const [step, setStep] = useState<'method' | 'input' | 'authenticating' | 'success' | 'error'>('method');
  const [selectedMethod, setSelectedMethod] = useState<AuthMethod>('web');
  const [alias, setAlias] = useState('');
  const [username, setUsername] = useState('');
  const [output, setOutput] = useState('');
  const [error, setError] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [authUrl, setAuthUrl] = useState('');
  const [deviceCode, setDeviceCode] = useState('');

  useInput((input, key) => {
    if (key.escape) {
      if (step === 'method') {
        onBack();
      } else {
        setStep('method');
      }
    }
  });

  const startAuthFlow = async () => {
    setIsProcessing(true);
    setOutput('');
    setError('');
    
    try {
      const args = ['org', 'login'];
      let process;
      
      switch (selectedMethod) {
        case 'web':
          args.push('web', '--browser', 'chrome');
          if (alias) args.push('--alias', alias);
          if (username) args.push('--username', username);
          break;
          
        case 'jwt':
          // This is a simplified example - in a real app, you'd collect these values
          args.push('jwt', '--username', username, '--jwt-key-file', 'path/to/server.key');
          if (alias) args.push('--alias', alias);
          break;
          
        case 'device':
          args.push('device', '--browser', 'chrome');
          if (alias) args.push('--alias', alias);
          break;
          
        case 'token':
          // This would be collected from user input
          args.push('access-token', '--instance-url', 'https://login.salesforce.com', '--access-token', 'YOUR_TOKEN');
          if (alias) args.push('--alias', alias);
          break;
          
        case 'soap':
          // This would be collected from user input
          args.push('soap', '--username', username, '--password', 'YOUR_PASSWORD');
          if (alias) args.push('--alias', alias);
          break;
      }
      
      process = execa('sf', args);
      
      // Handle output
      process.stdout?.on('data', (data) => {
        const output = data.toString();
        setOutput(prev => prev + output);
        
        // Handle web login URL
        if (selectedMethod === 'web' && output.includes('https://')) {
          const urlMatch = output.match(/https?:\/\/[^\s]+/);
          if (urlMatch) {
            setAuthUrl(urlMatch[0]);
            open(urlMatch[0]);
          }
        }
        
        // Handle device code flow
        if (selectedMethod === 'device') {
          if (output.includes('https://')) {
            const urlMatch = output.match(/https?:\/\/[^\s]+/);
            if (urlMatch) setAuthUrl(urlMatch[0]);
          }
          if (output.includes('code:')) {
            const codeMatch = output.match(/code:\s*([^\s]+)/);
            if (codeMatch) setDeviceCode(codeMatch[1]);
          }
        }
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      // If we get here, authentication was successful
      setStep('success');
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Unknown error occurred');
      setStep('error');
    } finally {
      setIsProcessing(false);
    }
  };

  const renderMethodStep = () => (
    <Box flexDirection="column">
      <Text bold>Authentication Method</Text>
      <Text>Choose how you'd like to authenticate with Salesforce:</Text>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={AUTH_METHODS.map(method => ({
            ...method,
            key: method.value,
          }))}
          onSelect={(item: any) => {
            setSelectedMethod(item.value as AuthMethod);
            if (item.requiresInput) {
              setStep('input');
            } else {
              setStep('authenticating');
              startAuthFlow();
            }
          }}
          itemComponent={({ isSelected, label, description }: { isSelected: boolean, label: string, description: string }) => (
            <Box>
              <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
              <Text>  </Text>
              <Text color="gray">{description}</Text>
            </Box>
          )}
        />
      </Box>
      
      <Text color="gray" italic>Use arrow keys to navigate, Enter to select, ESC to go back</Text>
    </Box>
  );

  const renderInputStep = () => {
    // In a real app, you'd have proper form handling for each auth method
    return (
      <Box flexDirection="column">
        <Text bold>Authentication Details</Text>
        <Text>Please provide the required information for {selectedMethod} authentication:</Text>
        
        <Box marginTop={1} marginBottom={2} flexDirection="column">
          <Box marginBottom={1}>
            <Text>Alias (optional): </Text>
            <TextInput
              value={alias}
              onChange={setAlias}
              placeholder="my-org-alias"
            />
          </Box>
          
          <Box marginBottom={2}>
            <Text>Username: </Text>
            <TextInput
              value={username}
              onChange={setUsername}
              placeholder="user@example.com"
            />
          </Box>
          
          {/* Additional fields would be rendered here based on auth method */}
          
          <Box flexDirection="column" marginTop={1}>
            <SelectInput
              items={[
                { label: 'Authenticate', value: 'auth' },
                { label: 'Back', value: 'back' },
              ]}
              onSelect={(item) => {
                if (item.value === 'auth') {
                  setStep('authenticating');
                  startAuthFlow();
                } else {
                  setStep('method');
                }
              }}
            />
          </Box>
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  const renderAuthenticatingStep = () => (
    <Box flexDirection="column">
      {isProcessing ? (
        <>
          <Text><Spinner type="dots" /> Authenticating...</Text>
          
          {authUrl && (
            <Box marginTop={1} marginBottom={1}>
              <Text>Please complete authentication in your browser:</Text>
              <Text color="cyan" underline>{authUrl}</Text>
            </Box>
          )}
          
          {deviceCode && (
            <Box marginTop={1} marginBottom={1}>
              <Text>Your device code: <Text bold>{deviceCode}</Text></Text>
            </Box>
          )}
          
          <Box marginTop={1} borderStyle="round" padding={1} height={10} overflow="hidden">
            <Text>{output || 'Starting authentication...'}</Text>
          </Box>
        </>
      ) : (
        <Text>Authentication complete!</Text>
      )}
    </Box>
  );

  const renderSuccessStep = () => (
    <Box flexDirection="column">
      <Text color="green">✓ Authentication successful!</Text>
      <Newline />
      <Text>You are now authenticated with Salesforce.</Text>
      {alias && <Text>Alias: <Text bold>{alias}</Text></Text>}
      <Newline />
      <Text>Press any key to continue...</Text>
    </Box>
  );

  const renderErrorStep = () => (
    <Box flexDirection="column">
      <Text color="red">✗ Authentication failed</Text>
      <Newline />
      <Text>Error: {error || 'Unknown error occurred'}</Text>
      <Newline />
      <Box borderStyle="round" padding={1} height={10} overflow="hidden">
        <Text>{output || 'No additional details available'}</Text>
      </Box>
      <Newline />
      <Text>Press any key to continue...</Text>
    </Box>
  );

  return (
    <Box flexDirection="column" padding={1}>
      <Box marginBottom={1}>
        <Text bold>Salesforce Authentication</Text>
      </Box>
      
      {step === 'method' && renderMethodStep()}
      {step === 'input' && renderInputStep()}
      {step === 'authenticating' && renderAuthenticatingStep()}
      {step === 'success' && renderSuccessStep()}
      {step === 'error' && renderErrorStep()}
      
      {(step === 'success' || step === 'error') && (
        <Box marginTop={1}>
          <Text>Press any key to continue...</Text>
        </Box>
      )}
      
      {step !== 'success' && step !== 'error' && step !== 'authenticating' && (
        <Text color="gray" italic>
          ESC to go back
        </Text>
      )}
    </Box>
  );
};

export default AuthManager;
</file>

<file path="src/components/common/Badge.tsx">
import React from 'react';
import { Text } from 'ink';
import { useTheme } from '../../themes';

type BadgeVariant = 
  | 'default'
  | 'primary'
  | 'secondary'
  | 'success'
  | 'warning'
  | 'error'
  | 'info'
  | 'outline';

type BadgeSize = 'sm' | 'md' | 'lg';

type BadgeProps = {
  /**
   * The content to display inside the badge
   */
  children: React.ReactNode;
  
  /**
   * The visual style variant of the badge
   * @default 'default'
   */
  variant?: BadgeVariant;
  
  /**
   * The size of the badge
   * @default 'md'
   */
  size?: BadgeSize;
  
  /**
   * Whether the badge should have a border
   * @default true
   */
  bordered?: boolean;
  
  /**
   * Whether the badge should have rounded corners
   * @default true
   */
  rounded?: boolean;
  
  /**
   * Custom styles for the badge
   */
  style?: React.CSSProperties;
  
  /**
   * Additional class name for the badge
   */
  className?: string;
};

/**
 * A badge component for displaying status, tags, or labels in the TUI
 */
const Badge: React.FC<BadgeProps> = ({
  children,
  variant = 'default',
  size = 'md',
  bordered = true,
  rounded = true,
  style = {},
  className = '',
}) => {
  const theme = useTheme();
  
  // Get size-based styles
  const getSizeStyles = (): React.CSSProperties => {
    switch (size) {
      case 'sm':
        return {
          paddingLeft: 1,
          paddingRight: 1,
          paddingTop: 0,
          paddingBottom: 0,
        };
      case 'lg':
        return {
          paddingLeft: 2,
          paddingRight: 2,
          paddingTop: 1,
          paddingBottom: 1,
        };
      case 'md':
      default:
        return {
          paddingLeft: 1,
          paddingRight: 1,
          paddingTop: 0,
          paddingBottom: 0,
        };
    }
  };
  
  // Get variant-based styles
  const getVariantStyles = (): React.CSSProperties => {
    switch (variant) {
      case 'primary':
        return {
          color: theme.colors.primaryForeground,
          backgroundColor: theme.colors.primary,
          borderColor: theme.colors.primaryBorder,
        };
      case 'secondary':
        return {
          color: theme.colors.secondaryForeground,
          backgroundColor: theme.colors.secondary,
          borderColor: theme.colors.secondaryBorder,
        };
      case 'success':
        return {
          color: theme.colors.successForeground,
          backgroundColor: theme.colors.success,
          borderColor: theme.colors.successBorder,
        };
      case 'warning':
        return {
          color: theme.colors.warningForeground,
          backgroundColor: theme.colors.warning,
          borderColor: theme.colors.warningBorder,
        };
      case 'error':
        return {
          color: theme.colors.errorForeground,
          backgroundColor: theme.colors.error,
          borderColor: theme.colors.errorBorder,
        };
      case 'info':
        return {
          color: theme.colors.infoForeground,
          backgroundColor: theme.colors.info,
          borderColor: theme.colors.infoBorder,
        };
      case 'outline':
        return {
          color: theme.colors.text,
          backgroundColor: 'transparent',
          borderColor: theme.colors.border,
        };
      case 'default':
      default:
        return {
          color: theme.colors.text,
          backgroundColor: theme.colors.backgroundHover,
          borderColor: theme.colors.border,
        };
    }
  };
  
  // Combine all styles
  const badgeStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    borderStyle: bordered ? 'single' : 'hidden',
    borderRadius: rounded ? 1 : 0,
    whiteSpace: 'nowrap',
    ...getSizeStyles(),
    ...getVariantStyles(),
    ...style,
  };
  
  return (
    <Text style={badgeStyles} className={className}>
      {children}
    </Text>
  );
};

export default Badge;
</file>

<file path="src/components/common/Box.tsx">
import React from 'react';
import { Box as InkBox, Text, useFocus, useInput } from 'ink';
import type { BoxProps as InkBoxProps } from 'ink';
import { useTheme } from '../../themes';
import { TextProps } from 'ink';

type BorderStyle = 'single' | 'double' | 'round' | 'single-double' | 'double-single' | 'classic' | 'none';

type BoxProps = {
  title?: string;
  titleAlign?: 'left' | 'center' | 'right';
  borderStyle?: BorderStyle;
  borderColor?: string;
  padding?: number;
  margin?: number;
  width?: number | string;
  height?: number | string;
  flexDirection?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  flexGrow?: number;
  flexShrink?: number;
  flexBasis?: string | number;
  alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justifyContent?: 'flex-start' | 'center' | 'flex-end' | 'space-between' | 'space-around';
  children: React.ReactNode;
  focusable?: boolean;
  onFocus?: () => void;
  onBlur?: () => void;
  onClick?: () => void;
  style?: React.CSSProperties;
};

const borderMap: Record<BorderStyle, [string, string, string, string, string, string, string, string]> = {
  single: ['┌', '┐', '└', '┘', '─', '│', '├', '┤'],
  double: ['╔', '╗', '╚', '╝', '═', '║', '╠', '╣'],
  round: ['╭', '╮', '╰', '╯', '─', '│', '├', '┤'],
  'single-double': ['╓', '╖', '╙', '╜', '─', '║', '╟', '╢'],
  'double-single': ['╒', '╕', '╘', '╛', '═', '│', '╞', '╡'],
  classic: ['+', '+', '+', '+', '-', '|', '+', '+'],
  none: [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
};

export const CustomBox: React.FC<BoxProps> = ({
  title,
  titleAlign = 'left',
  borderStyle = 'single',
  borderColor,
  padding = 1,
  margin = 0,
  width,
  height,
  flexDirection = 'column',
  flexGrow,
  flexShrink,
  flexBasis,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  children,
  focusable = false,
  onFocus,
  onBlur,
  onClick,
  style = {},
}) => {
  const theme = useTheme();
  const { isFocused } = useFocus({ isActive: focusable, autoFocus: false });
  
  // Handle click events
  useInput((input, key) => {
    if (focusable && isFocused && (input === ' ' || key.return) && onClick) {
      onClick();
    }
  }, { isActive: focusable });
  
  // Determine border characters based on style
  const [tl, tr, bl, br, h, v, l, r] = borderMap[borderStyle] || borderMap.single;
  
  // Calculate border color
  const borderColorValue = borderColor || (isFocused ? theme.colors.primary : theme.colors.border);
  
  // Calculate title position
  const renderTitle = () => {
    if (!title) return null;
    
    const titleText = ` ${title} `;
    const titleWidth = titleText.length;
    
    let titlePosition = 2; // Default left padding
    const boxWidth = typeof width === 'number' ? width - 4 : 20; // Default width if not specified
    
    if (titleAlign === 'center') {
      titlePosition = Math.max(2, Math.floor((boxWidth - titleWidth) / 2));
    } else if (titleAlign === 'right') {
      titlePosition = Math.max(2, boxWidth - titleWidth - 2);
    }
    
    return (
      <Text>
        {h.repeat(titlePosition)}
        <Text bold color={isFocused ? theme.colors.primary : theme.colors.text}>
          {titleText}
        </Text>
        {h.repeat(Math.max(0, boxWidth - titlePosition - titleWidth))}
      </Text>
    );
  };
  
  // Calculate content padding
  const contentPadding = typeof padding === 'number' ? 
    { left: padding, right: padding, top: padding, bottom: padding } :
    { left: 0, right: 0, top: 0, bottom: 0, ...padding };
  
  // Calculate margin
  const marginStyle = typeof margin === 'number' ? 
    { marginLeft: margin, marginRight: margin, marginTop: margin, marginBottom: margin } :
    { marginLeft: 0, marginRight: 0, marginTop: 0, marginBottom: 0, ...margin };
  
  // Calculate border styles
  const borderStyles: React.CSSProperties = {
    borderStyle: 'solid',
    borderColor: borderColorValue,
    borderLeft: isFocused ? `1 ${theme.colors.primary}` : `1 ${theme.colors.border}`,
    borderRight: isFocused ? `1 ${theme.colors.primary}` : `1 ${theme.colors.border}`,
    borderTop: isFocused ? `1 ${theme.colors.primary}` : `1 ${theme.colors.border}`,
    borderBottom: isFocused ? `1 ${theme.colors.primary}` : `1 ${theme.colors.border}`,
    ...style,
  };
  
  return (
    <InkBox 
      flexDirection="column" 
      width={width}
      height={height}
      flexGrow={flexGrow}
      flexShrink={flexShrink}
      flexBasis={flexBasis}
      {...marginStyle}
    >
      {/* Top border with title */}
      <Text>
        <Text color={borderColorValue}>{tl}</Text>
        {renderTitle()}
        <Text color={borderColorValue}>{tr}</Text>
      </Text>
      
      {/* Content */}
      <InkBox 
        flexDirection={flexDirection}
        alignItems={alignItems}
        justifyContent={justifyContent}
        paddingLeft={contentPadding.left}
        paddingRight={contentPadding.right}
        paddingTop={contentPadding.top}
        paddingBottom={contentPadding.bottom}
      >
        {children}
      </InkBox>
      
      {/* Bottom border */}
      <Text>
        <Text color={borderColorValue}>{bl}</Text>
        <Text color={borderColorValue}>{h.repeat(20)}</Text>
        <Text color={borderColorValue}>{br}</Text>
      </Text>
    </InkBox>
  );
};

export default CustomBox;
</file>

<file path="src/components/common/Button.tsx">
import React, { useCallback, useMemo } from 'react';
import { Text, useFocus, useInput, Box } from 'ink';
import { useTheme } from '../../themes';

type ButtonVariant = 'primary' | 'secondary' | 'success' | 'warning' | 'error' | 'info' | 'default';

type ButtonProps = {
  /**
   * Button text to display
   */
  children: React.ReactNode;
  
  /**
   * Button variant that determines the color scheme
   * @default 'default'
   */
  variant?: ButtonVariant;
  
  /**
   * Whether the button is disabled
   * @default false
   */
  disabled?: boolean;
  
  /**
   * Whether the button should take up the full width of its container
   * @default false
   */
  fullWidth?: boolean;
  
  /**
   * Whether the button should show a loading state
   * @default false
   */
  loading?: boolean;
  
  /**
   * Whether the button should be focusable
   * @default true
   */
  focusable?: boolean;
  
  /**
   * Callback when the button is clicked or activated with keyboard
   */
  onPress?: () => void;
  
  /**
   * Additional styles to apply to the button
   */
  style?: React.CSSProperties;
  
  /**
   * Additional props to pass to the underlying Box component
   */
  boxProps?: React.ComponentProps<typeof Box>;
};

/**
 * A customizable button component for the TUI
 */
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'default',
  disabled = false,
  fullWidth = false,
  loading = false,
  focusable = true,
  onPress,
  style = {},
  boxProps = {},
}) => {
  const theme = useTheme();
  const { isFocused } = useFocus({ 
    isActive: focusable && !disabled && !loading, 
    autoFocus: false 
  });
  
  // Handle button press (click or enter/space)
  useInput(
    (input, key) => {
      if ((input === ' ' || key.return) && onPress && !disabled && !loading) {
        onPress();
      }
    },
    { isActive: focusable && !disabled && !loading }
  );
  
  // Determine button colors based on variant and state
  const buttonColors = useMemo(() => {
    const colors = {
      default: {
        text: theme.colors.text,
        background: theme.colors.background,
        border: theme.colors.border,
        hoverText: theme.colors.text,
        hoverBackground: theme.colors.backgroundHover,
        activeBackground: theme.colors.highlight,
        disabledText: theme.colors.textMuted,
        disabledBackground: theme.colors.background,
        disabledBorder: theme.colors.border,
      },
      primary: {
        text: theme.colors.textInverse,
        background: theme.colors.primary,
        border: theme.colors.primary,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.primary,
        activeBackground: theme.colors.primary,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
      secondary: {
        text: theme.colors.textInverse,
        background: theme.colors.secondary,
        border: theme.colors.secondary,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.secondary,
        activeBackground: theme.colors.secondary,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
      success: {
        text: theme.colors.textInverse,
        background: theme.colors.success,
        border: theme.colors.success,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.success,
        activeBackground: theme.colors.success,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
      warning: {
        text: theme.colors.textInverse,
        background: theme.colors.warning,
        border: theme.colors.warning,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.warning,
        activeBackground: theme.colors.warning,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
      error: {
        text: theme.colors.textInverse,
        background: theme.colors.error,
        border: theme.colors.error,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.error,
        activeBackground: theme.colors.error,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
      info: {
        text: theme.colors.textInverse,
        background: theme.colors.info,
        border: theme.colors.info,
        hoverText: theme.colors.textInverse,
        hoverBackground: theme.colors.info,
        activeBackground: theme.colors.info,
        disabledText: theme.colors.textInverse,
        disabledBackground: theme.colors.textMuted,
        disabledBorder: theme.colors.textMuted,
      },
    };
    
    return colors[variant] || colors.default;
  }, [variant, theme]);
  
  // Determine button styles based on state
  const buttonStyles = useMemo(() => {
    const baseStyles: React.CSSProperties = {
      paddingLeft: 2,
      paddingRight: 2,
      paddingTop: 0,
      paddingBottom: 0,
      height: 3,
      minWidth: 10,
      justifyContent: 'center',
      alignItems: 'center',
      borderStyle: 'single',
      borderColor: buttonColors.border,
      backgroundColor: buttonColors.background,
      ...style,
    };
    
    if (disabled || loading) {
      return {
        ...baseStyles,
        borderColor: buttonColors.disabledBorder,
        backgroundColor: buttonColors.disabledBackground,
        opacity: 0.7,
      };
    }
    
    if (isFocused) {
      return {
        ...baseStyles,
        backgroundColor: buttonColors.hoverBackground,
        borderColor: buttonColors.border,
        borderStyle: 'double',
      };
    }
    
    return baseStyles;
  }, [buttonColors, disabled, isFocused, loading, style]);
  
  // Determine text styles based on state
  const textStyles = useMemo(() => {
    const baseStyles: React.CSSProperties = {
      color: buttonColors.text,
    };
    
    if (disabled || loading) {
      return {
        ...baseStyles,
        color: buttonColors.disabledText,
      };
    }
    
    if (isFocused) {
      return {
        ...baseStyles,
        color: buttonColors.hoverText,
        bold: true,
      };
    }
    
    return baseStyles;
  }, [buttonColors, disabled, isFocused, loading]);
  
  return (
    <Box
      {...boxProps}
      width={fullWidth ? '100%' : boxProps.width}
      flexGrow={fullWidth ? 1 : boxProps.flexGrow}
      flexDirection="row"
      alignItems="center"
      justifyContent="center"
      style={buttonStyles}
    >
      {loading ? (
        <Text {...textStyles}>
          <Text>⏳ </Text>
          <Text>Loading...</Text>
        </Text>
      ) : (
        <Text {...textStyles}>
          {isFocused && '> '}
          {children}
          {isFocused && ' <'}
        </Text>
      )}
    </Box>
  );
};

export default Button;
</file>

<file path="src/components/common/Card.tsx">
import React from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';

type CardVariant = 'default' | 'outline' | 'filled' | 'elevated';

type CardProps = {
  /**
   * The content of the card
   */
  children: React.ReactNode;
  
  /**
   * The title of the card (optional)
   */
  title?: string | React.ReactNode;
  
  /**
   * The footer content of the card (optional)
   */
  footer?: string | React.ReactNode;
  
  /**
   * The visual style variant of the card
   * @default 'default'
   */
  variant?: CardVariant;
  
  /**
   * Whether the card is hoverable
   * @default false
   */
  hoverable?: boolean;
  
  /**
   * Whether the card is selected
   * @default false
   */
  selected?: boolean;
  
  /**
   * Whether the card is clickable
   * @default false
   */
  clickable?: boolean;
  
  /**
   * Callback when the card is clicked
   */
  onClick?: () => void;
  
  /**
   * Additional styles for the card container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the card header
   */
  headerStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the card body
   */
  bodyStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the card footer
   */
  footerStyle?: React.CSSProperties;
  
  /**
   * Padding around the card content
   * @default 1
   */
  padding?: number;
  
  /**
   * Border radius of the card
   * @default 1
   */
  borderRadius?: number;
};

/**
 * A card component for displaying content in a contained, visually distinct area
 */
const Card: React.FC<CardProps> = ({
  children,
  title,
  footer,
  variant = 'default',
  hoverable = false,
  selected = false,
  clickable = false,
  onClick,
  style = {},
  headerStyle = {},
  bodyStyle = {},
  footerStyle = {},
  padding = 1,
  borderRadius = 1,
}) => {
  const theme = useTheme();
  
  // Handle click events
  const handleClick = () => {
    if (clickable && onClick) {
      onClick();
    }
  };
  
  // Get variant styles
  const getVariantStyles = (): React.CSSProperties => {
    switch (variant) {
      case 'outline':
        return {
          borderStyle: 'single',
          borderColor: selected ? theme.colors.primary : theme.colors.border,
          backgroundColor: 'transparent',
        };
      case 'filled':
        return {
          borderStyle: 'single',
          borderColor: selected ? theme.colors.primary : theme.colors.border,
          backgroundColor: theme.colors.backgroundHover,
        };
      case 'elevated':
        return {
          borderStyle: 'single',
          borderColor: selected ? theme.colors.primary : theme.colors.border,
          borderLeft: 'single',
          borderRight: 'single',
          borderBottom: 'single',
          borderTop: 'single',
          shadow: true,
        };
      case 'default':
      default:
        return {
          borderStyle: 'single',
          borderColor: selected ? theme.colors.primary : theme.colors.border,
          backgroundColor: theme.colors.background,
        };
    }
  };
  
  // Get hover styles
  const getHoverStyles = (): React.CSSProperties => {
    if (!hoverable && !clickable) return {};
    
    return {
      borderColor: theme.colors.primary,
      cursor: clickable ? 'pointer' : 'default',
    };
  };
  
  // Render the title
  const renderTitle = () => {
    if (!title) return null;
    
    return (
      <Box
        borderBottomStyle="single"
        borderColor={theme.colors.border}
        paddingX={padding}
        paddingY={0.5}
        style={{
          ...headerStyle,
        }}
      >
        {typeof title === 'string' ? (
          <Text bold>{title}</Text>
        ) : (
          title
        )}
      </Box>
    );
  };
  
  // Render the footer
  const renderFooter = () => {
    if (!footer) return null;
    
    return (
      <Box
        borderTopStyle="single"
        borderColor={theme.colors.border}
        paddingX={padding}
        paddingY={0.5}
        style={{
          ...footerStyle,
        }}
      >
        {typeof footer === 'string' ? (
          <Text>{footer}</Text>
        ) : (
          footer
        )}
      </Box>
    );
  };
  
  // Base card styles
  const cardStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    borderRadius,
    overflow: 'hidden',
    ...getVariantStyles(),
    ...(hoverable || clickable ? {
      ':hover': getHoverStyles(),
    } : {}),
    ...style,
  };
  
  // Body styles
  const bodyStyles: React.CSSProperties = {
    padding,
    ...bodyStyle,
  };
  
  return (
    <Box 
      style={cardStyles}
      onClick={handleClick}
      flexDirection="column"
    >
      {renderTitle()}
      <Box style={bodyStyles}>
        {children}
      </Box>
      {renderFooter()}
    </Box>
  );
};

export default Card;
</file>

<file path="src/components/common/Collapsible.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';
import { useMeasure } from '../../hooks/useMeasure';

type CollapsibleProps = {
  /**
   * The content to display when expanded
   */
  children: React.ReactNode;
  
  /**
   * The title or trigger element that toggles the content
   */
  title: string | React.ReactNode;
  
  /**
   * Whether the content is initially expanded
   * @default false
   */
  defaultExpanded?: boolean;
  
  /**
   * Whether the component is controlled externally
   * @default false
   */
  isExpanded?: boolean;
  
  /**
   * Callback when the expanded state changes
   */
  onToggle?: (isExpanded: boolean) => void;
  
  /**
   * The character to show when collapsed
   * @default '▶'
   */
  collapsedIcon?: string;
  
  /**
   * The character to show when expanded
   * @default '▼'
   */
  expandedIcon?: string;
  
  /**
   * Additional styles for the container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the header
   */
  headerStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the content
   */
  contentStyle?: React.CSSProperties;
  
  /**
   * Whether to show a border around the collapsible
   * @default false
   */
  bordered?: boolean;
};

/**
 * A collapsible component that can show/hide content with a smooth animation
 */
const Collapsible: React.FC<CollapsibleProps> = ({
  children,
  title,
  defaultExpanded = false,
  isExpanded: controlledExpanded,
  onToggle,
  collapsedIcon = '▶',
  expandedIcon = '▼',
  style = {},
  headerStyle = {},
  contentStyle = {},
  bordered = false,
}) => {
  const theme = useTheme();
  const [internalExpanded, setInternalExpanded] = useState(defaultExpanded);
  const [contentHeight, setContentHeight] = useState(0);
  const contentRef = useRef<HTMLDivElement>(null);
  
  // Determine if we're in controlled mode
  const isControlled = controlledExpanded !== undefined;
  const expanded = isControlled ? controlledExpanded : internalExpanded;
  
  // Measure the content height when it changes
  const [_, dimensions] = useMeasure(contentRef);
  const measuredHeight = dimensions?.height || 0;
  
  // Update content height when children change
  useEffect(() => {
    if (measuredHeight > 0) {
      setContentHeight(expanded ? measuredHeight : 0);
    }
  }, [expanded, measuredHeight]);
  
  // Handle toggle
  const handleToggle = () => {
    const newExpanded = !expanded;
    
    if (!isControlled) {
      setInternalExpanded(newExpanded);
    }
    
    if (onToggle) {
      onToggle(newExpanded);
    }
  };
  
  // Render the header
  const renderHeader = () => {
    const icon = expanded ? expandedIcon : collapsedIcon;
    
    return (
      <Box
        flexDirection="row"
        alignItems="center"
        onClick={handleToggle}
        style={{
          cursor: 'pointer',
          paddingLeft: 1,
          paddingRight: 1,
          paddingTop: 0.5,
          paddingBottom: 0.5,
          ...headerStyle,
        }}
      >
        <Text color={theme.colors.text}>
          {` ${icon} `}
        </Text>
        {typeof title === 'string' ? (
          <Text>{title}</Text>
        ) : (
          title
        )}
      </Box>
    );
  };
  
  // Render the content
  const renderContent = () => {
    return (
      <Box
        ref={contentRef}
        style={{
          overflow: 'hidden',
          height: contentHeight,
          transition: 'height 0.2s ease-in-out',
          ...contentStyle,
        }}
      >
        <Box>
          {children}
        </Box>
      </Box>
    );
  };
  
  return (
    <Box
      flexDirection="column"
      borderStyle={bordered ? 'single' : undefined}
      borderColor={theme.colors.border}
      style={style}
    >
      {renderHeader()}
      {renderContent()}
    </Box>
  );
};

// Named export 
export { Collapsible };
// Default export
export default Collapsible;
</file>

<file path="src/components/common/ConfirmDialog.tsx">
import React, { useCallback, useMemo } from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';
import Button from './Button';
import Modal from './Modal';

type ConfirmDialogProps = {
  /**
   * Whether the dialog is open
   * @default false
   */
  isOpen?: boolean;
  
  /**
   * Dialog title
   * @default 'Confirm'
   */
  title?: string;
  
  /**
   * The confirmation message to display
   */
  message: string | React.ReactNode;
  
  /**
   * Label for the confirm button
   * @default 'Confirm'
   */
  confirmLabel?: string;
  
  /**
   * Label for the cancel button
   * @default 'Cancel'
   */
  cancelLabel?: string;
  
  /**
   * Variant for the confirm button
   * @default 'primary'
   */
  confirmVariant?: 'primary' | 'danger' | 'success' | 'warning' | 'info' | 'default';
  
  /**
   * Variant for the cancel button
   * @default 'default'
   */
  cancelVariant?: 'primary' | 'danger' | 'success' | 'warning' | 'info' | 'default';
  
  /**
   * Whether to show the cancel button
   * @default true
   */
  showCancel?: boolean;
  
  /**
   * Whether the dialog should close when clicking the backdrop
   * @default true
   */
  closeOnBackdropClick?: boolean;
  
  /**
   * Callback when the dialog is confirmed
   */
  onConfirm: () => void;
  
  /**
   * Callback when the dialog is cancelled or closed
   */
  onCancel: () => void;
  
  /**
   * Additional styles for the dialog container
   */
  style?: React.CSSProperties;
};

/**
 * A confirmation dialog component for the TUI
 */
const ConfirmDialog: React.FC<ConfirmDialogProps> = ({
  isOpen = false,
  title = 'Confirm',
  message,
  confirmLabel = 'Confirm',
  cancelLabel = 'Cancel',
  confirmVariant = 'primary',
  cancelVariant = 'default',
  showCancel = true,
  closeOnBackdropClick = true,
  onConfirm,
  onCancel,
  style = {},
}) => {
  const theme = useTheme();
  
  // Handle confirm action
  const handleConfirm = useCallback(() => {
    onConfirm();
  }, [onConfirm]);
  
  // Handle cancel action
  const handleCancel = useCallback(() => {
    onCancel();
  }, [onCancel]);
  
  // Handle backdrop click
  const handleBackdropClick = useCallback(() => {
    if (closeOnBackdropClick) {
      onCancel();
    }
  }, [closeOnBackdropClick, onCancel]);
  
  // Footer with action buttons
  const footer = useMemo(() => (
    <Box justifyContent="flex-end" gap={1}>
      {showCancel && (
        <Button 
          variant={cancelVariant} 
          onPress={handleCancel}
        >
          {cancelLabel}
        </Button>
      )}
      <Button 
        variant={confirmVariant} 
        onPress={handleConfirm}
      >
        {confirmLabel}
      </Button>
    </Box>
  ), [
    showCancel, 
    cancelVariant, 
    cancelLabel, 
    confirmVariant, 
    confirmLabel, 
    handleCancel, 
    handleConfirm
  ]);
  
  // Content with message
  const content = useMemo(() => (
    <Box flexDirection="column" gap={1}>
      {typeof message === 'string' ? (
        <Text>{message}</Text>
      ) : (
        message
      )}
    </Box>
  ), [message]);
  
  return (
    <Modal
      isOpen={isOpen}
      title={title}
      onClose={handleCancel}
      style={style}
      showBackdrop={true}
      showCloseButton={false}
    >
      <Box flexDirection="column" gap={2}>
        {content}
        {footer}
      </Box>
    </Modal>
  );
};

export default ConfirmDialog;
</file>

<file path="src/components/common/Divider.tsx">
import React from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';

type DividerVariant = 'horizontal' | 'vertical';
type DividerOrientation = 'left' | 'center' | 'right';

type DividerProps = {
  /**
   * The label to display in the divider (optional)
   */
  label?: string | React.ReactNode;
  
  /**
   * The orientation of the divider
   * @default 'horizontal'
   */
  variant?: DividerVariant;
  
  /**
   * The position of the label (for horizontal dividers only)
   * @default 'center'
   */
  orientation?: DividerOrientation;
  
  /**
   * The character(s) to use for the divider line
   * @default '─' for horizontal, '│' for vertical
   */
  character?: string;
  
  /**
   * The color of the divider line
   * @default theme.colors.border
   */
  color?: string;
  
  /**
   * The color of the label text
   * @default theme.colors.text
   */
  labelColor?: string;
  
  /**
   * Additional styles for the divider container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the label
   */
  labelStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the line
   */
  lineStyle?: React.CSSProperties;
};

/**
 * A divider component for visually separating content
 */
const Divider: React.FC<DividerProps> = ({
  label,
  variant = 'horizontal',
  orientation = 'center',
  character,
  color,
  labelColor,
  style = {},
  labelStyle = {},
  lineStyle = {},
}) => {
  const theme = useTheme();
  
  // Default characters for divider
  const defaultCharacter = variant === 'horizontal' ? '─' : '│';
  const dividerChar = character || defaultCharacter;
  
  // Default colors
  const dividerColor = color || theme.colors.border;
  const textColor = labelColor || theme.colors.text;
  
  // Render a horizontal divider
  const renderHorizontalDivider = () => {
    if (!label) {
      return (
        <Box>
          <Text color={dividerColor} style={lineStyle}>
            {dividerChar.repeat(process.stdout.columns || 40)}
          </Text>
        </Box>
      );
    }
    
    // Calculate available width for the divider
    const availableWidth = process.stdout.columns || 80;
    const labelText = typeof label === 'string' ? label : '';
    const labelLength = labelText.length;
    const lineLength = Math.max(2, Math.floor((availableWidth - labelLength - 2) / 2));
    
    const leftLine = dividerChar.repeat(lineLength);
    const rightLine = dividerChar.repeat(lineLength);
    
    let content;
    
    switch (orientation) {
      case 'left':
        content = (
          <>
            <Text color={dividerColor} style={lineStyle}>
              {dividerChar.repeat(2)}
            </Text>
            <Text color={textColor} style={labelStyle}>
              {' '}{label}{' '}
            </Text>
            <Text color={dividerColor} style={lineStyle}>
              {dividerChar.repeat(availableWidth - labelLength - 6)}
            </Text>
          </>
        );
        break;
      case 'right':
        content = (
          <>
            <Text color={dividerColor} style={lineStyle}>
              {dividerChar.repeat(availableWidth - labelLength - 6)}
            </Text>
            <Text color={textColor} style={labelStyle}>
              {' '}{label}{' '}
            </Text>
            <Text color={dividerColor} style={lineStyle}>
              {dividerChar.repeat(2)}
            </Text>
          </>
        );
        break;
      case 'center':
      default:
        content = (
          <>
            <Text color={dividerColor} style={lineStyle}>
              {leftLine}
            </Text>
            <Text color={textColor} style={labelStyle}>
              {' '}{label}{' '}
            </Text>
            <Text color={dividerColor} style={lineStyle}>
              {rightLine}
            </Text>
          </>
        );
    }
    
    return (
      <Box>
        {content}
      </Box>
    );
  };
  
  // Render a vertical divider
  const renderVerticalDivider = () => {
    return (
      <Box flexDirection="column" alignItems="center" justifyContent="center">
        <Text color={dividerColor} style={lineStyle}>
          {dividerChar}
        </Text>
        {label && (
          <Text color={textColor} style={labelStyle}>
            {label}
          </Text>
        )}
      </Box>
    );
  };
  
  return (
    <Box 
      style={style}
      flexDirection={variant === 'horizontal' ? 'row' : 'column'}
      alignItems="center"
      justifyContent="center"
      width={variant === 'horizontal' ? '100%' : undefined}
      height={variant === 'vertical' ? '100%' : undefined}
    >
      {variant === 'horizontal' ? renderHorizontalDivider() : renderVerticalDivider()}
    </Box>
  );
};

export default Divider;
</file>

<file path="src/components/common/ErrorBoundary.tsx">
import React, { Component, ReactNode, ErrorInfo } from 'react';
import { Box, Text } from 'ink';
import { errorReporter, ErrorSeverity, ErrorCategory } from '../../utils/errorReporter';
import ErrorNotification from './ErrorNotification';

interface ErrorBoundaryProps {
  /**
   * The child components to render
   */
  children: ReactNode;
  
  /**
   * Optional identifier for this boundary to help with debugging
   */
  id?: string;
  
  /**
   * Component name or context for better error reporting
   */
  componentName?: string;
  
  /**
   * Whether to show the error UI or just silently report it
   * @default true
   */
  showError?: boolean;
  
  /**
   * Fallback UI to show when an error occurs
   * If not provided, a default error UI will be shown
   */
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
  errorId: string | null;
}

/**
 * Error boundary component to catch and handle errors in React component trees
 */
class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Report the error to our error reporting service
    const { id, componentName } = this.props;
    const context = componentName || (id ? `ErrorBoundary(${id})` : 'ErrorBoundary');
    
    const errorReport = errorReporter.reportError(`UI Error in ${context}`, {
      error,
      severity: ErrorSeverity.HIGH,
      category: ErrorCategory.UI,
      context,
      details: {
        componentStack: errorInfo.componentStack,
      },
      userAction: 'Try refreshing the application or report this issue to the developers.',
    });
    
    this.setState({
      errorInfo,
      errorId: errorReport.id,
    });
  }

  render(): ReactNode {
    const { children, showError = true, fallback } = this.props;
    const { hasError, error, errorId } = this.state;

    if (hasError) {
      if (!showError) {
        return null;
      }

      if (fallback) {
        return fallback;
      }

      if (error && errorId) {
        // Get the error report from the reporter
        const errorReport = errorReporter.getError(errorId);
        
        if (errorReport) {
          return (
            <Box flexDirection="column" paddingY={1}>
              <ErrorNotification error={errorReport} />
            </Box>
          );
        }
      }

      // Fallback error UI if we can't get the error report
      return (
        <Box flexDirection="column" borderStyle="round" borderColor="red" padding={1}>
          <Text bold color="red">An error occurred in this component</Text>
          {error && (
            <Text wrap>{error.message}</Text>
          )}
          <Text>Please try again or restart the application.</Text>
        </Box>
      );
    }

    return children;
  }
}

export default ErrorBoundary;
</file>

<file path="src/components/common/ErrorNotification.tsx">
import React, { useEffect, useState } from 'react';
import { Box, Text, useInput } from 'ink';
import { useTheme } from '../../themes';
import { ErrorReport, ErrorSeverity, errorReporter } from '../../utils/errorReporter';
import Divider from './Divider';
import { truncate } from '../../utils/helpers';

interface ErrorNotificationProps {
  /**
   * The error report to display
   */
  error: ErrorReport;
  
  /**
   * Whether to show detailed information
   * @default false
   */
  showDetails?: boolean;
  
  /**
   * Whether the notification should be dismissible
   * @default true
   */
  dismissible?: boolean;
  
  /**
   * Callback when the notification is dismissed
   */
  onDismiss?: () => void;
  
  /**
   * Time in milliseconds after which the notification will auto-dismiss
   * Set to 0 to disable auto-dismiss
   * @default 0
   */
  autoDismiss?: number;
  
  /**
   * Whether to mark the error as handled when dismissed
   * @default true
   */
  markAsHandled?: boolean;
}

/**
 * A specialized notification component for displaying error information
 */
const ErrorNotification: React.FC<ErrorNotificationProps> = ({
  error,
  showDetails = false,
  dismissible = true,
  onDismiss,
  autoDismiss = 0,
  markAsHandled = true,
}) => {
  const theme = useTheme();
  const [isVisible, setIsVisible] = useState(true);
  const [showDetailsState, setShowDetailsState] = useState(showDetails);
  
  // Get the appropriate color based on error severity
  const getSeverityColor = (severity: ErrorSeverity) => {
    switch (severity) {
      case ErrorSeverity.LOW:
        return theme.colors.info;
      case ErrorSeverity.MEDIUM:
        return theme.colors.warning;
      case ErrorSeverity.HIGH:
      case ErrorSeverity.CRITICAL:
        return theme.colors.error;
      default:
        return theme.colors.error;
    }
  };

  // Get severity display name
  const getSeverityName = (severity: ErrorSeverity) => {
    switch (severity) {
      case ErrorSeverity.LOW:
        return 'Minor';
      case ErrorSeverity.MEDIUM:
        return 'Warning';
      case ErrorSeverity.HIGH:
        return 'Error';
      case ErrorSeverity.CRITICAL:
        return 'Critical';
      default:
        return 'Error';
    }
  };
  
  // Handle auto-dismiss
  useEffect(() => {
    if (!isVisible || !autoDismiss) return;
    
    const timer = setTimeout(() => {
      handleDismiss();
    }, autoDismiss);
    
    return () => {
      clearTimeout(timer);
    };
  }, [isVisible, autoDismiss]);
  
  // Handle dismiss action
  const handleDismiss = () => {
    if (!dismissible && !autoDismiss) return;
    
    setIsVisible(false);
    
    if (markAsHandled) {
      errorReporter.markAsHandled(error.id);
    }
    
    if (onDismiss) {
      onDismiss();
    }
  };
  
  // Handle keyboard input
  useInput((input, key) => {
    if (key.escape && dismissible) {
      handleDismiss();
    }
    
    if (input === 'd' || input === 'D') {
      setShowDetailsState(!showDetailsState);
    }
  });
  
  // Don't render if not visible
  if (!isVisible) return null;
  
  const severityColor = getSeverityColor(error.severity);
  
  return (
    <Box 
      flexDirection="column"
      borderStyle="round"
      borderColor={severityColor}
      padding={1}
    >
      {/* Header with severity and category */}
      <Box flexDirection="row" justifyContent="space-between" alignItems="center">
        <Box>
          <Text bold color={severityColor}>
            {getSeverityName(error.severity)}: {error.category}
          </Text>
        </Box>
        {dismissible && (
          <Box>
            <Text 
              color={theme.colors.textMuted}
              dimColor
              onClick={handleDismiss}
            >
              [ESC to close]
            </Text>
          </Box>
        )}
      </Box>
      
      {/* Error message */}
      <Box marginY={1}>
        <Text wrap>{error.message}</Text>
      </Box>
      
      {/* User action suggestion if available */}
      {error.userAction && (
        <Box marginY={1}>
          <Text italic color={theme.colors.info}>
            Suggestion: {error.userAction}
          </Text>
        </Box>
      )}
      
      {/* Show details toggle */}
      <Box marginY={1}>
        <Text dimColor>
          Press 'D' to {showDetailsState ? 'hide' : 'show'} details
        </Text>
      </Box>
      
      {/* Error details when expanded */}
      {showDetailsState && (
        <Box flexDirection="column" marginTop={1}>
          <Divider />
          <Box marginY={1}>
            <Text bold>Error ID:</Text>
            <Text> </Text>
            <Text>{error.id}</Text>
          </Box>
          
          {error.context && (
            <Box marginY={1}>
              <Text bold>Context:</Text>
              <Text> </Text>
              <Text>{error.context}</Text>
            </Box>
          )}
          
          <Box marginY={1}>
            <Text bold>Time:</Text>
            <Text> </Text>
            <Text>{error.timestamp.toLocaleString()}</Text>
          </Box>
          
          {error.details && Object.keys(error.details).length > 0 && (
            <Box flexDirection="column" marginY={1}>
              <Text bold>Details:</Text>
              {Object.entries(error.details).map(([key, value]) => (
                <Text key={key}>
                  {key}: {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                </Text>
              ))}
            </Box>
          )}
          
          {error.error?.stack && (
            <Box flexDirection="column" marginY={1}>
              <Text bold>Stack Trace:</Text>
              <Box 
                flexDirection="column"
                borderStyle="single"
                borderColor={theme.colors.textMuted}
                paddingX={1}
                height={5}
                overflowY="scroll"
                marginTop={1}
              >
                {error.error.stack.split('\n').map((line, i) => (
                  <Text key={i} dimColor wrap>{truncate(line, 100)}</Text>
                ))}
              </Box>
            </Box>
          )}
        </Box>
      )}
    </Box>
  );
};

export default ErrorNotification;
</file>

<file path="src/components/common/ErrorProvider.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { Box } from 'ink';
import { errorReporter, ErrorReport } from '../../utils/errorReporter';
import ErrorNotification from './ErrorNotification';

// Create a context for errors
interface ErrorContextType {
  // List of active errors
  errors: ErrorReport[];
  // Dismiss a specific error
  dismissError: (errorId: string) => void;
  // Clear all errors
  clearErrors: () => void;
}

const ErrorContext = createContext<ErrorContextType>({
  errors: [],
  dismissError: () => {},
  clearErrors: () => {},
});

// Custom hook to access the error context
export const useErrors = () => useContext(ErrorContext);

interface ErrorProviderProps {
  children: ReactNode;
  
  /**
   * Maximum number of error notifications to show at once
   * @default 3
   */
  maxVisibleErrors?: number;
  
  /**
   * Whether to position the error container at the top or bottom
   * @default 'top'
   */
  position?: 'top' | 'bottom';
}

/**
 * Provider component that manages error notifications throughout the app
 */
const ErrorProvider: React.FC<ErrorProviderProps> = ({
  children,
  maxVisibleErrors = 3,
  position = 'top',
}) => {
  const [errors, setErrors] = useState<ErrorReport[]>([]);
  
  // Subscribe to error reporter
  useEffect(() => {
    const unsubscribe = errorReporter.subscribe((error) => {
      setErrors((prev) => {
        // Check if we already have this error
        if (prev.some(e => e.id === error.id)) {
          return prev;
        }
        // Add new error to the beginning of the array
        return [error, ...prev];
      });
    });
    
    return () => {
      unsubscribe();
    };
  }, []);
  
  // Dismiss a specific error
  const dismissError = (errorId: string) => {
    errorReporter.markAsHandled(errorId);
    setErrors((prev) => prev.filter(error => error.id !== errorId));
  };
  
  // Clear all errors
  const clearErrors = () => {
    errors.forEach(error => {
      errorReporter.markAsHandled(error.id);
    });
    setErrors([]);
  };
  
  // Visible errors (limited by maxVisibleErrors)
  const visibleErrors = errors.slice(0, maxVisibleErrors);
  
  return (
    <ErrorContext.Provider value={{ errors, dismissError, clearErrors }}>
      <Box flexDirection="column">
        {position === 'top' && visibleErrors.length > 0 && (
          <Box flexDirection="column" marginBottom={1}>
            {visibleErrors.map((error) => (
              <ErrorNotification
                key={error.id}
                error={error}
                onDismiss={() => dismissError(error.id)}
              />
            ))}
            {errors.length > maxVisibleErrors && (
              <Box justifyContent="center" marginY={1}>
                <Box borderStyle="single" paddingX={1}>
                  <Box>
                    {errors.length - maxVisibleErrors} more {errors.length - maxVisibleErrors === 1 ? 'error' : 'errors'} not shown
                  </Box>
                </Box>
              </Box>
            )}
          </Box>
        )}
        
        {children}
        
        {position === 'bottom' && visibleErrors.length > 0 && (
          <Box flexDirection="column" marginTop={1}>
            {visibleErrors.map((error) => (
              <ErrorNotification
                key={error.id}
                error={error}
                onDismiss={() => dismissError(error.id)}
              />
            ))}
            {errors.length > maxVisibleErrors && (
              <Box justifyContent="center" marginY={1}>
                <Box borderStyle="single" paddingX={1}>
                  <Box>
                    {errors.length - maxVisibleErrors} more {errors.length - maxVisibleErrors === 1 ? 'error' : 'errors'} not shown
                  </Box>
                </Box>
              </Box>
            )}
          </Box>
        )}
      </Box>
    </ErrorContext.Provider>
  );
};

export default ErrorProvider;
</file>

<file path="src/components/common/index.ts">
export { default as TextInput } from './TextInput';
export { default as Box } from './Box';
export { default as Button } from './Button';
export { default as Spinner } from './Spinner';
export { default as Tabs } from './Tabs';
export { default as Notification } from './Notification';
export { default as ErrorNotification } from './ErrorNotification';
export { default as ErrorBoundary } from './ErrorBoundary';
export { default as ErrorProvider } from './ErrorProvider';
export { useErrors } from './ErrorProvider';
export { default as ProgressBar } from './ProgressBar';
export { default as Modal } from './Modal';
export { default as ConfirmDialog } from './ConfirmDialog';
export { default as Tooltip } from './Tooltip';
export { default as Badge } from './Badge';
export { default as Table } from './Table';
export { default as Card } from './Card';
export { default as Divider } from './Divider';
export { default as Collapsible } from './Collapsible';
export { TreeView } from './TreeView';
// Export other common components here as we create them
</file>

<file path="src/components/common/Modal.tsx">
import React, { useCallback, useEffect } from 'react';
import { Box, Text, useFocus, useInput } from 'ink';
import { useTheme } from '../../themes';
import Button from './Button';

type ModalProps = {
  /**
   * Whether the modal is open
   * @default false
   */
  isOpen?: boolean;
  
  /**
   * Modal title
   */
  title: string;
  
  /**
   * Modal content
   */
  children: React.ReactNode;
  
  /**
   * Width of the modal
   * @default 60
   */
  width?: number;
  
  /**
   * Height of the modal
   */
  height?: number | 'auto';
  
  /**
   * Whether to show a close button
   * @default true
   */
  showCloseButton?: boolean;
  
  /**
   * Label for the close button
   * @default 'Close'
   */
  closeButtonLabel?: string;
  
  /**
   * Whether to show a backdrop
   * @default true
   */
  showBackdrop?: boolean;
  
  /**
   * Callback when the modal is closed
   */
  onClose?: () => void;
  
  /**
   * Additional styles for the modal container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional props for the modal content
   */
  contentProps?: React.ComponentProps<typeof Box>;
};

/**
 * A modal dialog component for the TUI
 */
const Modal: React.FC<ModalProps> = ({
  isOpen = false,
  title,
  children,
  width = 60,
  height = 'auto',
  showCloseButton = true,
  closeButtonLabel = 'Close',
  showBackdrop = true,
  onClose,
  style = {},
  contentProps = {},
}) => {
  const theme = useTheme();
  
  // Handle escape key to close modal
  useInput(
    (input, key) => {
      if (key.escape && onClose) {
        onClose();
      }
    },
    { isActive: isOpen }
  );
  
  // Prevent scrolling when modal is open
  useEffect(() => {
    if (isOpen) {
      // Add any necessary side effects when modal opens
      return () => {
        // Cleanup when modal closes
      };
    }
  }, [isOpen]);
  
  // Don't render if not open
  if (!isOpen) return null;
  
  // Calculate modal position and dimensions
  const modalStyles: React.CSSProperties = {
    position: 'absolute',
    left: '50%',
    top: '50%',
    transform: 'translate(-50%, -50%)',
    width: `${width}%`,
    maxWidth: '90%',
    minHeight: typeof height === 'number' ? `${height}%` : 'auto',
    maxHeight: '90%',
    backgroundColor: theme.colors.background,
    borderStyle: 'single',
    borderColor: theme.colors.border,
    flexDirection: 'column',
    ...style,
  };
  
  // Backdrop styles
  const backdropStyles: React.CSSProperties = {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  };
  
  // Header styles
  const headerStyles: React.CSSProperties = {
    borderBottomStyle: 'single',
    borderBottomColor: theme.colors.border,
    paddingX: 1,
    paddingY: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    height: 3,
  };
  
  // Content styles
  const contentStyles: React.CSSProperties = {
    padding: 1,
    flexGrow: 1,
    overflow: 'hidden',
  };
  
  // Footer styles
  const footerStyles: React.CSSProperties = {
    borderTopStyle: 'single',
    borderTopColor: theme.colors.border,
    padding: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    height: 4,
  };
  
  return (
    <Box {...(showBackdrop ? { style: backdropStyles } : {})}>
      <Box style={modalStyles}>
        {/* Header */}
        <Box style={headerStyles}>
          <Text bold>{title}</Text>
          {showCloseButton && onClose && (
            <Button 
              variant="text" 
              onPress={onClose}
              style={{ padding: 0, height: 1 }}
            >
              ✕
            </Button>
          )}
        </Box>
        
        {/* Content */}
        <Box {...contentProps} style={{ ...contentStyles, ...contentProps.style }}>
          {children}
        </Box>
        
        {/* Footer */}
        <Box style={footerStyles}>
          {onClose && (
            <Button 
              variant="secondary" 
              onPress={onClose}
            >
              {closeButtonLabel}
            </Button>
          )}
        </Box>
      </Box>
    </Box>
  );
};

export default Modal;
</file>

<file path="src/components/common/Notification.tsx">
import React, { useEffect, useState } from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';
import Spinner from './Spinner';

type NotificationType = 'info' | 'success' | 'warning' | 'error' | 'loading';

type NotificationProps = {
  /**
   * The type of notification to display
   * @default 'info'
   */
  type?: NotificationType;
  
  /**
   * The notification message to display
   */
  message: string | React.ReactNode;
  
  /**
   * Optional title for the notification
   */
  title?: string;
  
  /**
   * Whether the notification should be dismissible
   * @default false
   */
  dismissible?: boolean;
  
  /**
   * Callback when the notification is dismissed
   */
  onDismiss?: () => void;
  
  /**
   * Time in milliseconds after which the notification will auto-dismiss
   * Set to 0 to disable auto-dismiss
   * @default 5000
   */
  autoDismiss?: number;
  
  /**
   * Additional styles for the notification container
   */
  style?: React.CSSProperties;
};

/**
 * A notification component to display messages to the user
 */
const Notification: React.FC<NotificationProps> = ({
  type = 'info',
  message,
  title,
  dismissible = false,
  onDismiss,
  autoDismiss = 5000,
  style = {},
}) => {
  const theme = useTheme();
  const [isVisible, setIsVisible] = useState(true);
  
  // Icons for different notification types
  const icons = {
    info: 'ℹ️',
    success: '✅',
    warning: '⚠️',
    error: '❌',
    loading: '⏳',
  };
  
  // Colors for different notification types
  const colors = {
    info: theme.colors.info,
    success: theme.colors.success,
    warning: theme.colors.warning,
    error: theme.colors.error,
    loading: theme.colors.primary,
  };
  
  // Handle auto-dismiss
  useEffect(() => {
    if (!isVisible || !autoDismiss || type === 'loading') return;
    
    const timer = setTimeout(() => {
      handleDismiss();
    }, autoDismiss);
    
    return () => {
      clearTimeout(timer);
    };
  }, [isVisible, autoDismiss, type]);
  
  // Handle dismiss action
  const handleDismiss = () => {
    if (!dismissible && !autoDismiss) return;
    
    setIsVisible(false);
    if (onDismiss) {
      onDismiss();
    }
  };
  
  // Don't render if not visible
  if (!isVisible) return null;
  
  // Determine border style based on type
  const borderStyle = {
    single: {
      topLeft: '┌',
      topRight: '┐',
      bottomRight: '┘',
      bottomLeft: '└',
      horizontal: '─',
      vertical: '│',
    },
  };
  
  return (
    <Box 
      flexDirection="column"
      borderStyle="single"
      borderColor={colors[type]}
      paddingX={1}
      paddingY={0}
      style={{
        borderStyle: 'single',
        borderColor: colors[type],
        ...style,
      }}
    >
      {/* Header with title and dismiss button */}
      {(title || dismissible) && (
        <Box flexDirection="row" justifyContent="space-between" alignItems="center">
          <Box>
            <Text bold color={colors[type]}>
              {type !== 'loading' ? icons[type] + ' ' : ''}
              {title || type.charAt(0).toUpperCase() + type.slice(1)}
            </Text>
          </Box>
          {dismissible && (
            <Box>
              <Text 
                color={theme.colors.textMuted}
                onClick={handleDismiss}
                style={{ cursor: 'pointer' }}
              >
                ✕
              </Text>
            </Box>
          )}
        </Box>
      )}
      
      {/* Message content */}
      <Box paddingY={title || dismissible ? 1 : 0}>
        {type === 'loading' ? (
          <Box flexDirection="row" alignItems="center">
            <Spinner type="dots" color={colors[type]} />
            <Text> </Text>
            <Text>{message}</Text>
          </Box>
        ) : (
          <Text>{message}</Text>
        )}
      </Box>
    </Box>
  );
};

export default Notification;
</file>

<file path="src/components/common/ProgressBar.tsx">
import React, { useMemo } from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';

type ProgressBarVariant = 'default' | 'success' | 'warning' | 'error' | 'info' | 'primary' | 'secondary';

type ProgressBarProps = {
  /**
   * Current progress value (0-100)
   */
  value: number;
  
  /**
   * Total value (100 if not specified)
   * @default 100
   */
  total?: number;
  
  /**
   * Width of the progress bar in characters
   * @default 50
   */
  width?: number;
  
  /**
   * Whether to show the percentage
   * @default true
   */
  showPercentage?: boolean;
  
  /**
   * Whether to show the value and total
   * @default false
   */
  showValue?: boolean;
  
  /**
   * Custom label to display
   */
  label?: string;
  
  /**
   * Visual style variant
   * @default 'default'
   */
  variant?: ProgressBarVariant;
  
  /**
   * Character to use for the filled portion of the bar
   * @default '█'
   */
  filledChar?: string;
  
  /**
   * Character to use for the unfilled portion of the bar
   * @default '░'
   */
  unfilledChar?: string;
  
  /**
   * Additional styles for the progress bar container
   */
  style?: React.CSSProperties;
};

/**
 * A customizable progress bar component for the TUI
 */
const ProgressBar: React.FC<ProgressBarProps> = ({
  value,
  total = 100,
  width = 50,
  showPercentage = true,
  showValue = false,
  label,
  variant = 'default',
  filledChar = '█',
  unfilledChar = '░',
  style = {},
}) => {
  const theme = useTheme();
  
  // Calculate the percentage and ensure it's within bounds
  const percentage = useMemo(() => {
    return Math.min(100, Math.max(0, (value / total) * 100));
  }, [value, total]);
  
  // Calculate the number of filled and unfilled characters
  const filledWidth = Math.round((percentage / 100) * width);
  const unfilledWidth = width - filledWidth;
  
  // Generate the progress bar string
  const progressBar = useMemo(() => {
    const filled = filledChar.repeat(filledWidth);
    const unfilled = unfilledChar.repeat(unfilledWidth);
    return `${filled}${unfilled}`;
  }, [filledWidth, unfilledWidth, filledChar, unfilledChar]);
  
  // Get the color based on the variant
  const color = useMemo(() => {
    const colors = {
      default: theme.colors.text,
      primary: theme.colors.primary,
      secondary: theme.colors.secondary,
      success: theme.colors.success,
      warning: theme.colors.warning,
      error: theme.colors.error,
      info: theme.colors.info,
    };
    
    return colors[variant] || colors.default;
  }, [variant, theme]);
  
  // Format the value for display
  const formattedValue = useMemo(() => {
    if (!showValue) return null;
    return ` ${value}/${total}`;
  }, [value, total, showValue]);
  
  // Format the percentage for display
  const formattedPercentage = useMemo(() => {
    if (!showPercentage) return null;
    return ` ${percentage.toFixed(1)}%`;
  }, [percentage, showPercentage]);
  
  return (
    <Box flexDirection="column" style={style}>
      {(label || showValue || showPercentage) && (
        <Box marginBottom={1}>
          {label && <Text>{label}: </Text>}
          <Text color={color} bold>
            {formattedValue}
            {formattedPercentage}
          </Text>
        </Box>
      )}
      <Box>
        <Text color={color}>
          {progressBar}
        </Text>
      </Box>
    </Box>
  );
};

export default ProgressBar;
</file>

<file path="src/components/common/Spinner.tsx">
import React, { useEffect, useState } from 'react';
import { Text } from 'ink';
import { useTheme } from '../../themes';

type SpinnerType = 'dots' | 'line' | 'bounce' | 'arc' | 'arrow' | 'clock' | 'earth' | 'moon' | 'runner' | 'weather';

type SpinnerProps = {
  /**
   * Type of spinner animation
   * @default 'dots'
   */
  type?: SpinnerType;
  
  /**
   * Label to display next to the spinner
   */
  label?: string;
  
  /**
   * Color of the spinner
   * @default theme.colors.primary
   */
  color?: string;
  
  /**
   * Whether the spinner is active
   * @default true
   */
  isActive?: boolean;
  
  /**
   * Speed of the spinner in milliseconds
   * @default 100
   */
  speed?: number;
};

// Spinner frames for different types
const SPINNERS: Record<SpinnerType, string[]> = {
  dots: ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'],
  line: ['-', '\\', '|', '/'],
  bounce: ['⠁', '⠂', '⠄', '⠂'],
  arc: ['◜', '◠', '◝', '◞', '◡', '◟'],
  arrow: ['←', '↖', '↑', '↗', '→', '↘', '↓', '↙'],
  clock: ['🕛', '🕐', '🕑', '🕒', '🕓', '🕔', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚'],
  earth: ['🌍', '🌎', '🌏'],
  moon: ['🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'],
  runner: ['🚶', '🏃'],
  weather: ['☀️', '☀️', '☀️', '🌤️', '⛅', '🌥️', '☁️', '🌧️', '⛈️', '🌩️', '🌨️', '❄️'],
};

/**
 * A loading spinner component with multiple animation styles
 */
const Spinner: React.FC<SpinnerProps> = ({
  type = 'dots',
  label = '',
  color,
  isActive = true,
  speed = 100,
}) => {
  const theme = useTheme();
  const [frame, setFrame] = useState(0);
  const spinnerFrames = SPINNERS[type] || SPINNERS.dots;
  const spinnerColor = color || theme.colors.primary;
  
  // Animate the spinner
  useEffect(() => {
    if (!isActive) return;
    
    const timer = setInterval(() => {
      setFrame((prevFrame) => (prevFrame + 1) % spinnerFrames.length);
    }, speed);
    
    return () => {
      clearInterval(timer);
    };
  }, [isActive, speed, spinnerFrames.length]);
  
  if (!isActive) {
    return null;
  }
  
  return (
    <Text>
      <Text color={spinnerColor}>
        {spinnerFrames[frame]}
      </Text>
      {label && <Text> {label}</Text>}
    </Text>
  );
};

export default Spinner;
</file>

<file path="src/components/common/Table.tsx">
import React from 'react';
import { Box, Text } from 'ink';
import { useTheme } from '../../themes';
import { BorderBox } from './Box';

type ColumnDefinition<T> = {
  /**
   * Unique key for the column
   */
  key: string;
  
  /**
   * Header label for the column
   */
  header: string;
  
  /**
   * Function to render the cell content
   */
  render: (item: T) => React.ReactNode;
  
  /**
   * Width of the column (in characters or percentage)
   * @default 'auto'
   */
  width?: number | string;
  
  /**
   * Whether the column should be right-aligned
   * @default false
   */
  alignRight?: boolean;
  
  /**
   * Whether the column should be truncated with an ellipsis if content is too long
   * @default false
   */
  truncate?: boolean;
};

type TableProps<T> = {
  /**
   * Array of data items to display in the table
   */
  data: T[];
  
  /**
   * Column definitions for the table
   */
  columns: ColumnDefinition<T>[];
  
  /**
   * Key to use for each row (should be unique)
   */
  rowKey: keyof T | ((item: T) => string | number);
  
  /**
   * Whether to show the header row
   * @default true
   */
  showHeader?: boolean;
  
  /**
   * Whether to show borders around the table
   * @default true
   */
  bordered?: boolean;
  
  /**
   * Whether to add zebra striping to rows
   * @default true
   */
  striped?: boolean;
  
  /**
   * Whether to highlight rows on hover
   * @default false
   */
  highlightHover?: boolean;
  
  /**
   * Additional styles for the table container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the header row
   */
  headerStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the table rows
   */
  rowStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the table cells
   */
  cellStyle?: React.CSSProperties;
};

/**
 * A table component for displaying tabular data in the TUI
 */
function Table<T>({
  data,
  columns,
  rowKey,
  showHeader = true,
  bordered = true,
  striped = true,
  highlightHover = false,
  style = {},
  headerStyle = {},
  rowStyle = {},
  cellStyle = {},
}: TableProps<T>) {
  const theme = useTheme();
  
  // Get the row key from the item
  const getRowKey = (item: T): string => {
    if (typeof rowKey === 'function') {
      return String(rowKey(item));
    }
    return String(item[rowKey as keyof T]);
  };
  
  // Calculate column widths
  const columnWidths = columns.map(col => {
    if (col.width) return col.width;
    return 'auto';
  });
  
  // Render the header row
  const renderHeader = () => {
    if (!showHeader) return null;
    
    return (
      <Box 
        flexDirection="row"
        borderStyle={bordered ? 'single' : undefined}
        borderBottom={bordered}
        borderColor={theme.colors.border}
        paddingX={bordered ? 1 : 0}
        paddingY={bordered ? 0.5 : 0}
        style={{
          backgroundColor: theme.colors.backgroundHover,
          ...headerStyle,
        }}
      >
        {columns.map((col, colIndex) => (
          <Box
            key={col.key}
            width={columnWidths[colIndex]}
            justifyContent={col.alignRight ? 'flex-end' : 'flex-start'}
            paddingX={1}
          >
            <Text bold>{col.header}</Text>
          </Box>
        ))}
      </Box>
    );
  };
  
  // Render a single row
  const renderRow = (item: T, rowIndex: number) => {
    const key = getRowKey(item);
    const isEvenRow = rowIndex % 2 === 0;
    
    return (
      <Box
        key={key}
        flexDirection="row"
        borderStyle={bordered && rowIndex < data.length - 1 ? 'single' : undefined}
        borderBottom={bordered && rowIndex === data.length - 1 ? 'single' : undefined}
        borderColor={theme.colors.border}
        paddingX={bordered ? 1 : 0}
        paddingY={0.5}
        style={{
          backgroundColor: striped && isEvenRow ? theme.colors.backgroundHover : 'transparent',
          ...rowStyle,
        }}
        hoverStyle={highlightHover ? { backgroundColor: theme.colors.primaryMuted } : undefined}
      >
        {columns.map((col, colIndex) => (
          <Box
            key={`${key}-${col.key}`}
            width={columnWidths[colIndex]}
            justifyContent={col.alignRight ? 'flex-end' : 'flex-start'}
            paddingX={1}
            style={cellStyle}
          >
            {col.truncate ? (
              <Text>{String(col.render(item))}</Text>
            ) : (
              <Text>{col.render(item)}</Text>
            )}
          </Box>
        ))}
      </Box>
    );
  };
  
  return (
    <BorderBox 
      borderStyle={bordered ? 'single' : 'hidden'}
      borderColor={theme.colors.border}
      style={style}
    >
      {renderHeader()}
      <Box flexDirection="column">
        {data.map((item, index) => renderRow(item, index))}
      </Box>
    </BorderBox>
  );
}

export default Table;
</file>

<file path="src/components/common/Tabs.tsx">
import React, { useMemo } from 'react';
import { Box, Text, useFocus, useInput } from 'ink';
import { useTheme } from '../../themes';

type Tab = {
  id: string;
  label: string;
  icon?: string;
  disabled?: boolean;
};

type TabsProps = {
  /**
   * Array of tab objects with id and label
   */
  tabs: Tab[];
  
  /**
   * Currently active tab ID
   */
  activeTab: string;
  
  /**
   * Callback when a tab is selected
   */
  onTabChange: (tabId: string) => void;
  
  /**
   * Whether the tabs are focusable
   * @default true
   */
  focusable?: boolean;
  
  /**
   * Whether to show a border around the tabs
   * @default true
   */
  bordered?: boolean;
  
  /**
   * Additional styles for the tabs container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional props for the tabs container
   */
  boxProps?: React.ComponentProps<typeof Box>;
};

/**
 * A tabbed navigation component for the TUI
 */
const Tabs: React.FC<TabsProps> = ({
  tabs,
  activeTab,
  onTabChange,
  focusable = true,
  bordered = true,
  style = {},
  boxProps = {},
}) => {
  const theme = useTheme();
  const { isFocused } = useFocus({ 
    isActive: focusable, 
    autoFocus: false 
  });
  
  // Find the active tab index
  const activeIndex = useMemo(() => {
    return Math.max(0, tabs.findIndex(tab => tab.id === activeTab));
  }, [tabs, activeTab]);
  
  // Handle keyboard navigation
  useInput(
    (input, key) => {
      if (!focusable) return;
      
      if (key.leftArrow) {
        // Move to the previous tab
        const prevIndex = (activeIndex - 1 + tabs.length) % tabs.length;
        onTabChange(tabs[prevIndex].id);
      } else if (key.rightArrow) {
        // Move to the next tab
        const nextIndex = (activeIndex + 1) % tabs.length;
        onTabChange(tabs[nextIndex].id);
      } else if (key.return || key.space) {
        // Activate the focused tab
        onTabChange(tabs[activeIndex].id);
      } else if (key.tab) {
        // Handle tab key to cycle through tabs
        const direction = key.shift ? -1 : 1;
        const nextIndex = (activeIndex + direction + tabs.length) % tabs.length;
        onTabChange(tabs[nextIndex].id);
      }
    },
    { isActive: focusable }
  );
  
  // Calculate tab styles
  const getTabStyles = (tab: Tab, index: number) => {
    const isActive = tab.id === activeTab;
    const isFocusedTab = isFocused && index === activeIndex;
    
    const baseStyles: React.CSSProperties = {
      paddingLeft: 2,
      paddingRight: 2,
      paddingTop: 0,
      paddingBottom: 0,
      height: 3,
      justifyContent: 'center',
      alignItems: 'center',
      borderStyle: 'single',
      borderColor: isActive ? theme.colors.primary : theme.colors.border,
      borderTop: true,
      borderLeft: true,
      borderRight: true,
      borderBottom: !isActive,
      backgroundColor: isActive ? theme.colors.primary : theme.colors.background,
      marginRight: 1,
    };
    
    if (isFocusedTab) {
      baseStyles.borderStyle = 'round';
      baseStyles.borderColor = theme.colors.primary;
    }
    
    if (tab.disabled) {
      baseStyles.opacity = 0.5;
      baseStyles.borderColor = theme.colors.border;
      baseStyles.backgroundColor = theme.colors.backgroundHover;
    }
    
    return baseStyles;
  };
  
  // Calculate tab text styles
  const getTabTextStyles = (tab: Tab, index: number) => {
    const isActive = tab.id === activeTab;
    const isFocusedTab = isFocused && index === activeIndex;
    
    const baseStyles: React.CSSProperties = {
      color: isActive ? theme.colors.textInverse : theme.colors.text,
    };
    
    if (isFocusedTab) {
      baseStyles.underline = true;
      baseStyles.bold = true;
    }
    
    if (tab.disabled) {
      baseStyles.color = theme.colors.textMuted;
    }
    
    return baseStyles;
  };
  
  return (
    <Box 
      flexDirection="column"
      {...boxProps}
      style={{
        borderStyle: bordered ? 'single' : 'none',
        borderColor: theme.colors.border,
        paddingLeft: 1,
        paddingRight: 1,
        paddingTop: 0,
        paddingBottom: 0,
        ...style,
      }}
    >
      <Box flexDirection="row" marginBottom={0}>
        {tabs.map((tab, index) => (
          <Box
            key={tab.id}
            onClick={() => !tab.disabled && onTabChange(tab.id)}
            style={getTabStyles(tab, index)}
          >
            <Text {...getTabTextStyles(tab, index)}>
              {tab.icon && <Text>{tab.icon} </Text>}
              {tab.label}
            </Text>
          </Box>
        ))}
      </Box>
      
      {/* Active tab content */}
      <Box 
        borderStyle="single"
        borderColor={theme.colors.border}
        borderTop={false}
        padding={1}
      >
        {tabs.find(tab => tab.id === activeTab)?.content}
      </Box>
    </Box>
  );
};

export default Tabs;
</file>

<file path="src/components/common/TextInput.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { Text, useInput, Box } from 'ink';

type Props = {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  onSubmit?: (value: string) => void;
  focus?: boolean;
  mask?: string;
  showCursor?: boolean;
  highlightPastedText?: boolean;
  validate?: (value: string) => boolean | string;
  width?: number;
  multiline?: boolean;
};

export const TextInput = ({
  value: originalValue,
  onChange,
  placeholder = '',
  onSubmit,
  focus: customFocus = true,
  mask,
  showCursor = true,
  validate,
  width,
  multiline = false,
}: Props) => {
  const [cursorOffset, setCursorOffset] = useState(originalValue.length);
  const [validationError, setValidationError] = useState<string | null>(null);
  const [focus, setFocus] = useState(customFocus);
  const [temporaryValue, setTemporaryValue] = useState(originalValue);
  
  // Handle external value changes
  useEffect(() => {
    setTemporaryValue(originalValue);
    setCursorOffset(originalValue.length);
  }, [originalValue]);
  
  // Handle validation
  useEffect(() => {
    if (validate) {
      const validationResult = validate(temporaryValue);
      if (validationResult === false) {
        setValidationError('Invalid input');
      } else if (typeof validationResult === 'string') {
        setValidationError(validationResult);
      } else {
        setValidationError(null);
      }
    }
  }, [temporaryValue, validate]);
  
  // Handle cursor position
  const handleInput = useCallback((input: string, key: any) => {
    if (key.upArrow || key.downArrow || (key.ctrl && input === 'c') || key.escape) {
      return;
    }
    
    let newValue = temporaryValue;
    let newCursorOffset = cursorOffset;
    
    if (key.return) {
      if (onSubmit && (!validate || !validationError)) {
        onSubmit(temporaryValue);
      }
      return;
    }
    
    if (key.leftArrow) {
      if (key.ctrl) {
        // Move to the beginning of the previous word
        const words = temporaryValue.split(/\s+/);
        let currentPos = 0;
        for (let i = 0; i < words.length; i++) {
          if (currentPos + words[i].length >= cursorOffset) {
            if (i > 0) {
              newCursorOffset = temporaryValue.indexOf(words[i - 1]);
            } else {
              newCursorOffset = 0;
            }
            break;
          }
          currentPos += words[i].length + 1; // +1 for the space
        }
      } else {
        newCursorOffset = Math.max(0, cursorOffset - 1);
      }
    } else if (key.rightArrow) {
      if (key.ctrl) {
        // Move to the beginning of the next word
        const words = temporaryValue.split(/\s+/);
        let currentPos = 0;
        for (let i = 0; i < words.length; i++) {
          currentPos += words[i].length;
          if (currentPos > cursorOffset) {
            newCursorOffset = Math.min(temporaryValue.length, currentPos + 1);
            break;
          }
          currentPos += 1; // for the space
        }
      } else {
        newCursorOffset = Math.min(temporaryValue.length, cursorOffset + 1);
      }
    } else if (key.delete) {
      // Delete forward
      newValue = 
        temporaryValue.slice(0, cursorOffset) + 
        temporaryValue.slice(cursorOffset + 1);
    } else if (key.backspace || key.delete) {
      // Delete backward
      if (cursorOffset > 0) {
        newValue = 
          temporaryValue.slice(0, cursorOffset - 1) + 
          temporaryValue.slice(cursorOffset);
        newCursorOffset = cursorOffset - 1;
      }
    } else if (key.home) {
      newCursorOffset = 0;
    } else if (key.end) {
      newCursorOffset = temporaryValue.length;
    } else if (
      input.length > 0 &&
      !key.ctrl &&
      !key.meta &&
      !key.alt
    ) {
      // Insert text at cursor position
      newValue = 
        temporaryValue.slice(0, cursorOffset) + 
        input + 
        temporaryValue.slice(cursorOffset);
      newCursorOffset = cursorOffset + input.length;
    }
    
    if (newValue !== temporaryValue) {
      setTemporaryValue(newValue);
      onChange(newValue);
    }
    
    if (newCursorOffset !== cursorOffset) {
      setCursorOffset(newCursorOffset);
    }
  }, [temporaryValue, cursorOffset, onChange, onSubmit, validate, validationError]);
  
  useInput(handleInput, { isActive: focus });
  
  // Handle focus changes
  useEffect(() => {
    setFocus(customFocus);
  }, [customFocus]);
  
  // Calculate cursor position and visible text
  const displayValue = mask ? mask.repeat(temporaryValue.length) : temporaryValue;
  const cursorChar = '█';
  
  // Split the value into before and after the cursor
  const beforeCursor = displayValue.slice(0, cursorOffset);
  const afterCursor = displayValue.slice(cursorOffset);
  
  // Calculate the visible part of the input if width is constrained
  let visibleBeforeCursor = beforeCursor;
  let visibleAfterCursor = afterCursor;
  
  if (width) {
    const maxVisible = Math.max(0, width - 1); // Leave space for cursor
    
    if (beforeCursor.length > maxVisible) {
      visibleBeforeCursor = '…' + beforeCursor.slice(-maxVisible + 1);
    }
    
    if (afterCursor.length + visibleBeforeCursor.length > maxVisible) {
      const remainingSpace = Math.max(0, maxVisible - visibleBeforeCursor.length - 1);
      visibleAfterCursor = afterCursor.slice(0, remainingSpace) + (afterCursor.length > remainingSpace ? '…' : '');
    }
  }
  
  // Render the input field with cursor
  return (
    <Box flexDirection="column">
      <Box>
        <Text>{visibleBeforeCursor}</Text>
        {focus && showCursor && (
          <Text inverse>{cursorChar || ' '}</Text>
        )}
        <Text>{visibleAfterCursor || (focus && showCursor ? ' ' : '')}</Text>
        {!visibleBeforeCursor && !visibleAfterCursor && !focus && (
          <Text dimColor>{placeholder}</Text>
        )}
      </Box>
      {validationError && (
        <Text color="red">{validationError}</Text>
      )}
    </Box>
  );
};

export default TextInput;
</file>

<file path="src/components/common/Tooltip.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Box, Text, useFocus, useInput } from 'ink';
import { useTheme } from '../../themes';

type TooltipPosition = 'top' | 'right' | 'bottom' | 'left';

type TooltipProps = {
  /**
   * The content that will trigger the tooltip on hover/focus
   */
  children: React.ReactNode;
  
  /**
   * The tooltip content to display
   */
  content: string | React.ReactNode;
  
  /**
   * Position of the tooltip relative to the trigger element
   * @default 'top'
   */
  position?: TooltipPosition;
  
  /**
   * Delay in milliseconds before showing the tooltip
   * @default 300
   */
  delay?: number;
  
  /**
   * Whether the tooltip is disabled
   * @default false
   */
  disabled?: boolean;
  
  /**
   * Additional styles for the tooltip container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the tooltip content
   */
  contentStyle?: React.CSSProperties;
  
  /**
   * Whether to show an arrow pointing to the trigger element
   * @default true
   */
  showArrow?: boolean;
};

/**
 * A tooltip component that displays additional information on hover or focus
 */
const Tooltip: React.FC<TooltipProps> = ({
  children,
  content,
  position = 'top',
  delay = 300,
  disabled = false,
  style = {},
  contentStyle = {},
  showArrow = true,
}) => {
  const theme = useTheme();
  const [isVisible, setIsVisible] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [isHovered, setIsHovered] = useState(false);
  const [isDelayed, setIsDelayed] = useState(true);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Handle mouse enter
  const handleMouseEnter = () => {
    if (disabled) return;
    
    setIsHovered(true);
    
    if (delay > 0) {
      setIsDelayed(true);
      timeoutRef.current = setTimeout(() => {
        setIsDelayed(false);
      }, delay);
    } else {
      setIsDelayed(false);
    }
  };
  
  // Handle mouse leave
  const handleMouseLeave = () => {
    setIsHovered(false);
    setIsDelayed(true);
    
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  
  // Handle focus
  const handleFocus = () => {
    if (disabled) return;
    setIsFocused(true);
    setIsDelayed(false);
  };
  
  // Handle blur
  const handleBlur = () => {
    setIsFocused(false);
  };
  
  // Update visibility based on hover/focus state
  useEffect(() => {
    setIsVisible((isHovered || isFocused) && !isDelayed);
  }, [isHovered, isFocused, isDelayed]);
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  
  // Calculate tooltip position styles
  const getPositionStyles = (): React.CSSProperties => {
    const baseStyles: React.CSSProperties = {
      position: 'absolute',
      zIndex: 1000,
      backgroundColor: theme.colors.backgroundInverse,
      color: theme.colors.textInverse,
      paddingLeft: 1,
      paddingRight: 1,
      paddingTop: 0,
      paddingBottom: 0,
      borderStyle: 'single',
      borderColor: theme.colors.border,
      ...contentStyle,
    };
    
    const arrowSize = 1;
    const arrow = showArrow ? '▶' : ''; // Simple arrow, can be styled better
    
    switch (position) {
      case 'top':
        return {
          ...baseStyles,
          bottom: '100%',
          left: '50%',
          transform: 'translateX(-50%)',
          marginBottom: arrowSize,
          '::after': {
            content: `'${arrow}'`,
            position: 'absolute',
            top: '100%',
            left: '50%',
            transform: 'translateX(-50%) rotate(90deg)',
          },
        };
      case 'right':
        return {
          ...baseStyles,
          left: '100%',
          top: '50%',
          transform: 'translateY(-50%)',
          marginLeft: arrowSize,
          '::after': {
            content: `'${arrow}'`,
            position: 'absolute',
            left: `-${arrowSize}`,
            top: '50%',
            transform: 'translateY(-50%) rotate(180deg)',
          },
        };
      case 'bottom':
        return {
          ...baseStyles,
          top: '100%',
          left: '50%',
          transform: 'translateX(-50%)',
          marginTop: arrowSize,
          '::after': {
            content: `'${arrow}'`,
            position: 'absolute',
            bottom: '100%',
            left: '50%',
            transform: 'translateX(-50%) rotate(-90deg)',
          },
        };
      case 'left':
        return {
          ...baseStyles,
          right: '100%',
          top: '50%',
          transform: 'translateY(-50%)',
          marginRight: arrowSize,
          '::after': {
            content: `'${arrow}'`,
            position: 'absolute',
            right: `-${arrowSize}`,
            top: '50%',
            transform: 'translateY(-50%)',
          },
        };
      default:
        return baseStyles;
    }
  };
  
  // Don't render anything if disabled
  if (disabled) {
    return <>{children}</>;
  }
  
  return (
    <Box 
      position="relative" 
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      style={style}
    >
      <Box 
        onFocus={handleFocus}
        onBlur={handleBlur}
        tabIndex={0} // Make the trigger focusable
      >
        {children}
      </Box>
      
      {isVisible && (
        <Box {...getPositionStyles()}>
          {typeof content === 'string' ? (
            <Text>{content}</Text>
          ) : (
            content
          )}
        </Box>
      )}
    </Box>
  );
};

export default Tooltip;
</file>

<file path="src/components/common/TreeView.tsx">
import React, { useState, useCallback } from 'react';
import { Box, Text, useFocus } from 'ink';
import { useTheme } from '../../themes';
import { Collapsible } from './Collapsible';
// Import the custom typings we created
import '../../types/ink-components';

type TreeNode = {
  /**
   * The unique identifier for the node
   */
  id: string;
  
  /**
   * The display label for the node
   */
  label: string;
  
  /**
   * Optional icon to display before the label
   */
  icon?: string;
  
  /**
   * Whether the node is expanded by default
   * @default false
   */
  isExpanded?: boolean;
  
  /**
   * Child nodes (for nested structures)
   */
  children?: TreeNode[];
  
  /**
   * Additional data associated with the node
   */
  data?: Record<string, any>;
  
  /**
   * Whether the node is selectable
   * @default true
   */
  selectable?: boolean;
  
  /**
   * Whether the node is currently selected
   * @default false
   */
  isSelected?: boolean;
};

type TreeViewProps = {
  /**
   * The tree data to display
   */
  data: TreeNode[];
  
  /**
   * Callback when a node is selected
   */
  onSelect?: (node: TreeNode) => void;
  
  /**
   * Callback when a node is toggled (expanded/collapsed)
   */
  onToggle?: (node: TreeNode, isExpanded: boolean) => void;
  
  /**
   * The currently selected node ID
   */
  selectedId?: string | null;
  
  /**
   * The depth of the current level (used internally for indentation)
   * @internal
   */
  depth?: number;
  
  /**
   * Additional styles for the tree container
   */
  style?: React.CSSProperties;
  
  /**
   * Additional styles for the node container
   */
  nodeStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the node label
   */
  labelStyle?: React.CSSProperties;
  
  /**
   * Additional styles for the selected node
   */
  selectedStyle?: React.CSSProperties;
};

/**
 * A recursive tree view component for displaying hierarchical data
 */
const TreeView: React.FC<TreeViewProps> = ({
  data,
  onSelect,
  onToggle,
  selectedId,
  depth = 0,
  style = {},
  nodeStyle = {},
  labelStyle = {},
  selectedStyle = {},
}) => {
  const theme = useTheme();
  
  // Handle node selection
  const handleSelect = useCallback((node: TreeNode) => {
    if (node.selectable !== false && onSelect) {
      onSelect(node);
    }
  }, [onSelect]);
  
  // Handle node toggle (expand/collapse)
  const handleToggle = useCallback((node: TreeNode, isExpanded: boolean) => {
    if (onToggle) {
      onToggle(node, isExpanded);
    }
  }, [onToggle]);
  
  // Render a single tree node
  const renderNode = (node: TreeNode, index: number) => {
    const hasChildren = node.children && node.children.length > 0;
    const isSelected = selectedId === node.id;
    const indent = depth * 2;
    
    // Default styles
    const defaultNodeStyle: React.CSSProperties = {
      marginLeft: indent,
      paddingLeft: 1,
      paddingRight: 1,
      ...(node.selectable !== false ? {} : { opacity: 0.7 }),
      ...nodeStyle,
    };
    
    const defaultLabelStyle: React.CSSProperties = {
      color: isSelected ? theme.colors.primary : theme.colors.text,
      ...labelStyle,
    };
    
    const selectedNodeStyle: React.CSSProperties = isSelected ? {
      backgroundColor: theme.colors.primaryBackground,
      ...selectedStyle,
    } : {};
    
    // Make a leaf node (no children) selectable with keyboard
    const handleLeafSelect = () => {
      if (node.selectable !== false && onSelect) {
        onSelect(node);
      }
    };
    
    // Render a leaf node (no children)
    if (!hasChildren) {
      return (
        <Box 
          key={node.id || index}
          borderStyle="none"
          style={{
            ...defaultNodeStyle,
            ...selectedNodeStyle,
          }}
        >
          <Text 
            style={defaultLabelStyle}
            // Use Ink's native focus handling instead of onClick
            dimColor={!isSelected}
          >
            {node.icon && <Text>{node.icon} </Text>}
            <Text>{node.label}</Text>
            {/* Add an invisible character for focusing that triggers selection */}
            {node.selectable !== false && (
              <Text
                color="transparent"
                dimColor
                onFocus={() => isSelected || handleSelect(node)}
              >
                •
              </Text>
            )}
          </Text>
        </Box>
      );
    }
    
    // Render a parent node with children
    return (
      <Collapsible
        key={node.id || index}
        title={
          <Text style={defaultLabelStyle}>
            {node.icon && <Text>{node.icon} </Text>}
            {node.label}
          </Text>
        }
        defaultExpanded={node.isExpanded}
        onToggle={(isExpanded) => handleToggle(node, isExpanded)}
        headerStyle={{
          ...defaultNodeStyle,
          ...(isSelected ? selectedNodeStyle : {}),
          paddingLeft: 0,
        }}
        contentStyle={{
          paddingLeft: 0,
        }}
      >
        <TreeView
          data={node.children || []}
          onSelect={onSelect}
          onToggle={onToggle}
          selectedId={selectedId}
          depth={depth + 1}
          style={style}
          nodeStyle={nodeStyle}
          labelStyle={labelStyle}
          selectedStyle={selectedStyle}
        />
      </Collapsible>
    );
  };
  
  return (
    <Box flexDirection="column" style={style}>
      {data.map((node, index) => renderNode(node, index))}
    </Box>
  );
};

export { TreeView };
export type { TreeNode, TreeViewProps };
</file>

<file path="src/components/metadata/MetadataTools.tsx">
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import { TextInput } from '../common/TextInput';
import { ErrorBoundary, useErrors } from '../common';
import { errorReporter, ErrorCategory, ErrorSeverity } from '../../utils';

type MetadataTool = {
  id: string;
  label: string;
  description: string;
  requiresTargetOrg?: boolean;
  requiresSourceOrg?: boolean;
  requiresManifest?: boolean;
  requiresMetadata?: boolean;
};

type MetadataToolsProps = {
  onBack: () => void;
};

const METADATA_TOOLS: MetadataTool[] = [
  {
    id: 'deploy',
    label: 'Deploy Metadata',
    description: 'Deploy metadata to an org',
    requiresTargetOrg: true,
    requiresManifest: true,
  },
  {
    id: 'retrieve',
    label: 'Retrieve Metadata',
    description: 'Retrieve metadata from an org',
    requiresSourceOrg: true,
    requiresManifest: true,
  },
  {
    id: 'deploy-dir',
    label: 'Deploy Directory',
    description: 'Deploy all metadata from a directory',
    requiresTargetOrg: true,
  },
  {
    id: 'retrieve-dir',
    label: 'Retrieve to Directory',
    description: 'Retrieve metadata to a directory',
    requiresSourceOrg: true,
  },
  {
    id: 'validate',
    label: 'Validate Deployment',
    description: 'Validate a deployment without making changes',
    requiresTargetOrg: true,
    requiresManifest: true,
  },
  {
    id: 'list',
    label: 'List Metadata',
    description: 'List metadata in an org',
    requiresSourceOrg: true,
  },
  {
    id: 'describe',
    label: 'Describe Metadata',
    description: 'Describe metadata types in an org',
    requiresSourceOrg: true,
  },
];

export const MetadataTools = ({ onBack }: MetadataToolsProps) => {
  // Get access to the error handling system
  const { errors, dismissError } = useErrors();
  const [selectedTool, setSelectedTool] = useState<MetadataTool | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [output, setOutput] = useState('');
  const [error, setError] = useState('');
  const [targetOrg, setTargetOrg] = useState('');
  const [sourceOrg, setSourceOrg] = useState('');
  const [manifestFile, setManifestFile] = useState('manifest/package.xml');
  const [metadata, setMetadata] = useState('');
  const [directory, setDirectory] = useState('force-app/main/default');
  const [isProcessing, setIsProcessing] = useState(false);

  // In a real app, you would load orgs here
  const loadOrgs = async () => {
    // This would be populated with actual orgs from the CLI
    return [
      { username: 'dev@example.com', isDefault: true },
      { username: 'test@example.com', isDefault: false },
    ];
  };

  const runCommand = async (command: string, args: string[] = []) => {
    try {
      setIsProcessing(true);
      setOutput('');
      setError('');
      
      const process = execa('sf', [command, ...args]);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      return true;
    } catch (err) {
      const errorMessage = `Error: ${err instanceof Error ? err.message : String(err)}`;
      setError(errorMessage);
      
      // Report error to the error reporting system
      errorReporter.reportCommandError(
        `Failed to execute Salesforce CLI command: sf ${command} ${args.join(' ')}`,
        err instanceof Error ? err : new Error(String(err)),
        { command, args }
      );
      
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const handleToolSelect = (tool: MetadataTool) => {
    setSelectedTool(tool);
  };

  const executeTool = async () => {
    if (!selectedTool) return;
    
    try {
      setIsProcessing(true);
      setOutput('');
      setError('');
      
      let command = 'project';
      const args: string[] = [];
      
      // Validate required fields
      if (selectedTool.requiresTargetOrg && !targetOrg) {
        setError('Target org is required for this operation');
        errorReporter.reportValidationError(
          `Target org is required for the ${selectedTool.label} operation`,
          undefined,
          { tool: selectedTool.id }
        );
        setIsProcessing(false);
        return;
      }
      
      if (selectedTool.requiresSourceOrg && !sourceOrg) {
        setError('Source org is required for this operation');
        errorReporter.reportValidationError(
          `Source org is required for the ${selectedTool.label} operation`,
          undefined,
          { tool: selectedTool.id }
        );
        setIsProcessing(false);
        return;
      }
      
      if (selectedTool.requiresManifest && !manifestFile) {
        setError('Manifest file is required for this operation');
        errorReporter.reportValidationError(
          `Manifest file is required for the ${selectedTool.label} operation`,
          undefined,
          { tool: selectedTool.id }
        );
        setIsProcessing(false);
        return;
      }
      
      switch (selectedTool.id) {
        case 'deploy':
          command = 'project';
          args.push('deploy', 'start', '--manifest', manifestFile);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'retrieve':
          command = 'project';
          args.push('retrieve', 'start', '--manifest', manifestFile);
          if (sourceOrg) args.push('--source-org', sourceOrg);
          break;
          
        case 'deploy-dir':
          command = 'project';
          args.push('deploy', 'start', '--source-dir', directory);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'retrieve-dir':
          command = 'project';
          args.push('retrieve', 'start', '--output-dir', directory);
          if (sourceOrg) args.push('--source-org', sourceOrg);
          break;
          
        case 'validate':
          command = 'project';
          args.push('deploy', 'validate', '--manifest', manifestFile);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'list':
          command = 'org';
          args.push('list', 'metadata');
          if (sourceOrg) args.push('--target-org', sourceOrg);
          if (metadata) args.push('--metadata', metadata);
          break;
          
        case 'describe':
          command = 'org';
          args.push('describe', 'metadata');
          if (sourceOrg) args.push('--target-org', sourceOrg);
          break;
      }
      
      await runCommand(command, args);
    } catch (err) {
      const errorMessage = `Failed to execute ${selectedTool.label}: ${err instanceof Error ? err.message : String(err)}`;
      setError(errorMessage);
      
      // Report error to the error reporting system
      errorReporter.reportError(`Failed to execute ${selectedTool.label}`, {
        error: err instanceof Error ? err : new Error(String(err)),
        severity: ErrorSeverity.MEDIUM,
        category: ErrorCategory.COMMAND,
        context: 'MetadataTools.executeTool',
        details: { tool: selectedTool },
        userAction: 'Check the command parameters and try again.'
      });
    } finally {
      setIsProcessing(false);
    }
  };

  useInput((input, key) => {
    if (key.escape) {
      if (selectedTool) {
        setSelectedTool(null);
      } else {
        onBack();
      }
    }
  });

  const renderToolList = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Metadata Tools</Text>
      </Box>
      
      <Box marginBottom={2}>
        <SelectInput
          items={METADATA_TOOLS.map(tool => ({
            ...tool,
            label: `${tool.label} - ${tool.description}`,
            value: tool.id,
          }))}
          onSelect={(item) => handleToolSelect(item as unknown as MetadataTool)}
          itemComponent={({ isSelected, label }) => (
            <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
          )}
        />
      </Box>
      
      <Text color="gray" italic>Use arrow keys to navigate, Enter to select, ESC to go back</Text>
    </Box>
  );

  const renderToolForm = () => {
    if (!selectedTool) return null;
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>{selectedTool.label}</Text>
        </Box>
        
        <Box marginBottom={1}>
          <Text>{selectedTool.description}</Text>
        </Box>
        
        <Box flexDirection="column" marginTop={1}>
          {selectedTool.requiresTargetOrg && (
            <Box marginBottom={1}>
              <Text>Target Org: </Text>
              <TextInput
                value={targetOrg}
                onChange={setTargetOrg}
                placeholder="username or alias"
              />
            </Box>
          )}
          
          {selectedTool.requiresSourceOrg && (
            <Box marginBottom={1}>
              <Text>Source Org: </Text>
              <TextInput
                value={sourceOrg}
                onChange={setSourceOrg}
                placeholder="username or alias"
              />
            </Box>
          )}
          
          {selectedTool.requiresManifest && (
            <Box marginBottom={1}>
              <Text>Manifest File: </Text>
              <TextInput
                value={manifestFile}
                onChange={setManifestFile}
                placeholder="path/to/package.xml"
              />
            </Box>
          )}
          
          {(selectedTool.id === 'deploy-dir' || selectedTool.id === 'retrieve-dir') && (
            <Box marginBottom={1}>
              <Text>Directory: </Text>
              <TextInput
                value={directory}
                onChange={setDirectory}
                placeholder="path/to/directory"
              />
            </Box>
          )}
          
          {selectedTool.id === 'list' && (
            <Box marginBottom={1}>
              <Text>Metadata Type (optional): </Text>
              <TextInput
                value={metadata}
                onChange={setMetadata}
                placeholder="ApexClass,CustomObject,..."
              />
            </Box>
          )}
          
          <Box marginTop={2} marginBottom={2}>
            <SelectInput
              items={[
                { label: 'Run Command', value: 'run' },
                { label: 'Back to Tools', value: 'back' },
              ]}
              onSelect={(item) => {
                if (item.value === 'run') {
                  executeTool();
                } else {
                  setSelectedTool(null);
                }
              }}
            />
          </Box>
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  const renderOutput = () => {
    if (!output && !error) return null;
    
    return (
      <Box marginTop={2} flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Output:</Text>
        </Box>
        <Box borderStyle="round" padding={1} height={10} overflow="hidden">
          <Text>{error || output}</Text>
        </Box>
      </Box>
    );
  };

  return (
    <Box flexDirection="column" padding={1}>
      {isProcessing ? (
        <Box>
          <Text><Spinner type="dots" /> Processing...</Text>
        </Box>
      ) : selectedTool ? (
        <>
          {renderToolForm()}
          {renderOutput()}
        </>
      ) : (
        renderToolList()
      )}
    </Box>
  );
};

// Export with ErrorBoundary
export default function MetadataToolsWithErrorBoundary(props: MetadataToolsProps) {
  return (
    <ErrorBoundary componentName="MetadataTools">
      <MetadataTools {...props} />
    </ErrorBoundary>
  );
};
</file>

<file path="src/components/org/OrgManager.tsx">
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa, ExecaChildProcess } from 'execa';
import Spinner from 'ink-spinner';
import { ErrorBoundary, useErrors } from '../common';
import { errorReporter, ErrorCategory, ErrorSeverity } from '../../utils';

type Org = {
  alias?: string;
  username: string;
  orgId: string;
  instanceUrl: string;
  isActive: boolean;
  isDefaultDevHub: boolean;
  isDefaultUsername: boolean;
  connectedStatus: string;
  status: string;
};

type OrgManagerProps = {
  onBack: () => void;
};

export const OrgManager = ({ onBack }: OrgManagerProps) => {
  // Get access to the error handling system
  const { errors, dismissError } = useErrors();
  const [orgs, setOrgs] = useState<Org[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedOrg, setSelectedOrg] = useState<Org | null>(null);
  const [output, setOutput] = useState<string>('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [confirmDelete, setConfirmDelete] = useState(false);

  // Load orgs on component mount
  useEffect(() => {
    loadOrgs();
  }, []);

  const loadOrgs = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Run sf org list command
      const { stdout } = await execa('sf', ['org', 'list', '--json']);
      const result = JSON.parse(stdout);
      
      if (result.status === 0 && result.result) {
        setOrgs(result.result.nonScratchOrgs.concat(result.result.scratchOrgs || []));
      } else {
        setOrgs([]);
        // Report a warning if no orgs found
        if (!result.result || 
            ((!result.result.nonScratchOrgs || result.result.nonScratchOrgs.length === 0) && 
             (!result.result.scratchOrgs || result.result.scratchOrgs.length === 0))) {
          errorReporter.reportError('No Salesforce orgs found', {
            severity: ErrorSeverity.LOW,
            category: ErrorCategory.AUTH,
            context: 'OrgManager',
            userAction: 'Use the Auth Manager to log in to a Salesforce org.'
          });
        }
      }
    } catch (err) {
      // Update local state for backward compatibility
      const errorMessage = `Failed to load orgs: ${err instanceof Error ? err.message : String(err)}`;
      setError(errorMessage);
      setOrgs([]);
      
      // Report error to the error reporting system
      errorReporter.reportError('Failed to load Salesforce orgs', {
        error: err instanceof Error ? err : new Error(String(err)),
        severity: ErrorSeverity.HIGH,
        category: ErrorCategory.COMMAND,
        context: 'OrgManager.loadOrgs',
        userAction: 'Check if Salesforce CLI is installed and properly configured.'
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleOrgSelect = (org: Org) => {
    setSelectedOrg(org);
  };

  const runCommand = async (command: string, args: string[] = []) => {
    try {
      setIsProcessing(true);
      setOutput('');
      
      const process = execa('sf', [command, ...args]);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      // Refresh org list after command completes
      await loadOrgs();
    } catch (err) {
      const errorMessage = `Error: ${err instanceof Error ? err.message : String(err)}`;
      setOutput(errorMessage);
      
      // Report error to the error reporting system
      errorReporter.reportCommandError(
        `Failed to execute Salesforce CLI command: sf ${command} ${args.join(' ')}`,
        err instanceof Error ? err : new Error(String(err)),
        { command, args }
      );
    } finally {
      setIsProcessing(false);
    }
  };

  const openOrg = (org: Org) => {
    runCommand('org', ['open', '-o', org.username]);
  };

  const setDefaultOrg = (org: Org) => {
    runCommand('config', ['set', 'target-org', org.username, '--global']);
  };

  const setDefaultDevHub = (org: Org) => {
    runCommand('config', ['set', 'target-dev-hub', org.username, '--global']);
  };

  const refreshOrg = (org: Org) => {
    runCommand('org', ['display', '-o', org.username, '--verbose']);
  };

  const deleteOrg = async (org: Org) => {
    // Check if it's a scratch org first
    const isScratchOrg = org.status === 'Active' && org.username.includes('test.com');
    
    if (isScratchOrg) {
      // For scratch orgs, use delete command
      await runCommand('org', ['delete', 'scratch', '-o', org.username, '--no-prompt']);
    } else {
      // For other orgs, just remove the auth information
      await runCommand('auth', ['logout', '-o', org.username, '--no-prompt']);
    }
    
    // Refresh org list after deletion
    await loadOrgs();
    setSelectedOrg(null);
  };

  useInput((input, key) => {
    if (key.escape) {
      if (confirmDelete) {
        setConfirmDelete(false);
      } else if (selectedOrg) {
        setSelectedOrg(null);
      } else {
        onBack();
      }
    }
  });

  if (isLoading) {
    return (
      <Box>
        <Text><Spinner type="dots" /> Loading orgs...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box flexDirection="column">
        <Text color="red">Error: {error}</Text>
        <Text>Press ESC to go back</Text>
      </Box>
    );
  }

  if (selectedOrg) {
    if (confirmDelete) {
      return (
        <Box flexDirection="column">
          <Box marginBottom={1}>
            <Text bold color="red">⚠️  Delete Org Confirmation</Text>
          </Box>
          
          <Box marginBottom={2}>
            <Text>Are you sure you want to delete the org <Text bold>{selectedOrg.alias || selectedOrg.username}</Text>?</Text>
            <Text>This action {selectedOrg.username.includes('test.com') ? 'will PERMANENTLY delete the scratch org' : 'will revoke authentication for this org'}.</Text>
          </Box>
          
          <Box flexDirection="column" marginBottom={2}>
            <SelectInput
              items={[
                { label: '❌ Cancel - Keep this org', value: 'cancel' },
                { label: '⚠️ Yes, DELETE this org', value: 'confirm' },
              ]}
              onSelect={(item) => {
                if (item.value === 'confirm') {
                  deleteOrg(selectedOrg);
                } else {
                  setConfirmDelete(false);
                }
              }}
            />
          </Box>
          
          <Text color="gray" italic>
            Press ESC to cancel
          </Text>
        </Box>
      );
    }
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Org: {selectedOrg.alias || selectedOrg.username}</Text>
          <Text>  </Text>
          {selectedOrg.isDefaultUsername && <Text color="green">[Default]</Text>}
          {selectedOrg.isDefaultDevHub && <Text color="blue"> [DevHub]</Text>}
        </Box>
        
        <Box marginBottom={1}>
          <Text>Status: {selectedOrg.status}</Text>
        </Box>
        
        <Box marginBottom={2}>
          <Text>Instance: {selectedOrg.instanceUrl}</Text>
        </Box>
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              { label: 'Open Org in Browser', value: 'open' },
              { label: 'Set as Default Org', value: 'set-default' },
              { label: 'Set as Default Dev Hub', value: 'set-dev-hub' },
              { label: 'Refresh Org Info', value: 'refresh' },
              { label: 'Delete Org', value: 'delete' },
              { label: 'Back to List', value: 'back' },
            ]}
            onSelect={(item) => {
              switch (item.value) {
                case 'open':
                  openOrg(selectedOrg);
                  break;
                case 'set-default':
                  setDefaultOrg(selectedOrg);
                  break;
                case 'set-dev-hub':
                  setDefaultDevHub(selectedOrg);
                  break;
                case 'refresh':
                  refreshOrg(selectedOrg);
                  break;
                case 'delete':
                  setConfirmDelete(true);
                  break;
                case 'back':
                  setSelectedOrg(null);
                  break;
              }
            }}
          />
        </Box>
        
        {isProcessing && (
          <Box>
            <Text><Spinner type="dots" /> Processing...</Text>
          </Box>
        )}
        
        {output && (
          <Box flexDirection="column" borderStyle="round" padding={1}>
            <Text bold>Output:</Text>
            <Text>{output}</Text>
          </Box>
        )}
        
        <Text color="gray" italic>
          Press ESC to go back
        </Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Your Salesforce Orgs</Text>
      </Box>
      
      {orgs.length === 0 ? (
        <Text>No orgs found. Use 'sf org login web' to authenticate with an org.</Text>
      ) : (
        <Box flexDirection="column">
          <SelectInput
            items={orgs.map(org => ({
              label: `${org.isDefaultUsername ? '★ ' : '  '}${org.alias || org.username}`,
              value: org.username,
              org
            }))}
            onSelect={(item: any) => handleOrgSelect(item.org)}
            itemComponent={({ isSelected, label, org }: { isSelected: boolean, label: string, org: Org }) => (
              <Box>
                <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
                <Text>  </Text>
                <Text color="gray">
                  {org.instanceUrl} {org.isDefaultDevHub && '(DevHub)'}
                </Text>
              </Box>
            )}
          />
        </Box>
      )}
      
      <Box marginTop={1}>
        <Text>Press ESC to go back</Text>
      </Box>
    </Box>
  );
};

// Export with ErrorBoundary
export default function OrgManagerWithErrorBoundary(props: OrgManagerProps) {
  return (
    <ErrorBoundary componentName="OrgManager">
      <OrgManager {...props} />
    </ErrorBoundary>
  );
};
</file>

<file path="src/components/plugins/PluginsPanel.tsx">
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import { TextInput } from '../common/TextInput';

type Plugin = {
  name: string;
  version: string;
  type: string;
  location?: string;
  homepage?: string;
  updateAvailable?: boolean;
  latestVersion?: string;
};

type PluginsPanelProps = {
  onBack: () => void;
};

export const PluginsPanel = ({ onBack }: PluginsPanelProps) => {
  const [plugins, setPlugins] = useState<Plugin[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [output, setOutput] = useState('');
  const [selectedPlugin, setSelectedPlugin] = useState<Plugin | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [view, setView] = useState<'list' | 'details' | 'install' | 'update' | 'uninstall'>('list');
  const [searchQuery, setSearchQuery] = useState('');
  const [installPluginName, setInstallPluginName] = useState('');
  const [isCheckingForUpdates, setIsCheckingForUpdates] = useState(false);

  // Load plugins on component mount
  useEffect(() => {
    loadPlugins();
  }, []);

  const loadPlugins = async () => {
    try {
      setIsLoading(true);
      setError('');
      
      // Run sf plugins command
      const { stdout } = await execa('sf', ['plugins', '--json']);
      const result = JSON.parse(stdout);
      
      if (Array.isArray(result)) {
        setPlugins(result);
      } else {
        setPlugins([]);
      }
    } catch (err) {
      setError(`Failed to load plugins: ${err instanceof Error ? err.message : String(err)}`);
      setPlugins([]);
    } finally {
      setIsLoading(false);
    }
  };

  const checkForUpdates = async () => {
    try {
      setIsCheckingForUpdates(true);
      setOutput('');
      
      const process = execa('sf', ['plugins', 'update', '--json']);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      // Reload plugins after update check
      await loadPlugins();
    } catch (err) {
      setError(`Error checking for updates: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setIsCheckingForUpdates(false);
    }
  };

  const runCommand = async (command: string, args: string[] = []) => {
    try {
      setIsProcessing(true);
      setOutput('');
      
      const process = execa('sf', [command, ...args]);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      // Reload plugins after command completes
      await loadPlugins();
      return true;
    } catch (err) {
      setOutput(`Error: ${err instanceof Error ? err.message : String(err)}`);
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const installPlugin = async (pluginName: string) => {
    const success = await runCommand('plugins', ['install', pluginName]);
    if (success) {
      setInstallPluginName('');
      setView('list');
    }
  };

  const updatePlugin = async (pluginName: string) => {
    await runCommand('plugins', ['update', pluginName]);
  };

  const uninstallPlugin = async (pluginName: string) => {
    await runCommand('plugins', ['uninstall', pluginName]);
    setSelectedPlugin(null);
    setView('list');
  };

  const updateAllPlugins = async () => {
    await runCommand('plugins', ['update']);
  };

  const handlePluginSelect = (plugin: Plugin) => {
    setSelectedPlugin(plugin);
    setView('details');
  };

  useInput((input, key) => {
    if (key.escape) {
      if (view !== 'list') {
        setView('list');
        setSelectedPlugin(null);
      } else {
        onBack();
      }
    }
  });

  const renderPluginList = () => {
    const filteredPlugins = plugins.filter(plugin => 
      plugin.name.toLowerCase().includes(searchQuery.toLowerCase())
    );

    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Installed Plugins</Text>
        </Box>
        
        <Box marginBottom={1}>
          <Text>Search: </Text>
          <TextInput
            value={searchQuery}
            onChange={setSearchQuery}
            placeholder="Filter plugins..."
          />
        </Box>
        
        {isLoading ? (
          <Box>
            <Text><Spinner type="dots" /> Loading plugins...</Text>
          </Box>
        ) : error ? (
          <Text color="red">Error: {error}</Text>
        ) : filteredPlugins.length === 0 ? (
          <Text>No plugins found. Install some plugins to get started.</Text>
        ) : (
          <Box flexDirection="column">
            <Box marginBottom={1}>
              <SelectInput
                items={[
                  ...filteredPlugins.map(plugin => ({
                    label: `${plugin.name}@${plugin.version} ${plugin.updateAvailable ? '🔄' : ''}`,
                    value: plugin.name,
                    plugin
                  })),
                  { label: '➕ Install New Plugin', value: 'install' },
                  { label: '🔄 Update All Plugins', value: 'update-all' },
                  { label: '🔍 Check for Updates', value: 'check-updates' },
                ]}
                onSelect={(item) => {
                  if (item.value === 'install') {
                    setView('install');
                  } else if (item.value === 'update-all') {
                    updateAllPlugins();
                  } else if (item.value === 'check-updates') {
                    checkForUpdates();
                  } else {
                    // Type assertion for custom plugin property
                    const customItem = item as any;
                    handlePluginSelect(customItem.plugin);
                  }
                }}
                itemComponent={({ isSelected, label, plugin }) => (
                  <Box>
                    <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
                    {plugin?.updateAvailable && (
                      <Text color="yellow"> (update to {plugin.latestVersion} available)</Text>
                    )}
                  </Box>
                )}
              />
            </Box>
          </Box>
        )}
        
        <Box marginTop={1}>
          <Text>Press ESC to go back</Text>
        </Box>
      </Box>
    );
  };

  const renderPluginDetails = () => {
    if (!selectedPlugin) return null;
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Plugin: {selectedPlugin.name}</Text>
        </Box>
        
        <Box marginBottom={1}>
          <Text>Version: {selectedPlugin.version}</Text>
          {selectedPlugin.updateAvailable && (
            <Text color="yellow">Update available: {selectedPlugin.latestVersion}</Text>
          )}
        </Box>
        
        <Box marginBottom={1}>
          <Text>Type: {selectedPlugin.type}</Text>
        </Box>
        
        {selectedPlugin.location && (
          <Box marginBottom={1}>
            <Text>Location: {selectedPlugin.location}</Text>
          </Box>
        )}
        
        {selectedPlugin.homepage && (
          <Box marginBottom={2}>
            <Text>Homepage: {selectedPlugin.homepage}</Text>
          </Box>
        )}
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              ...(selectedPlugin.updateAvailable ? [{
                label: `🔄 Update to v${selectedPlugin.latestVersion}`,
                value: 'update',
              }] : []),
              { label: 'Uninstall Plugin', value: 'uninstall' },
              { label: 'Back to List', value: 'back' },
            ]}
            onSelect={(item) => {
              switch (item.value) {
                case 'update':
                  setView('update');
                  updatePlugin(selectedPlugin.name);
                  break;
                case 'uninstall':
                  setView('uninstall');
                  break;
                case 'back':
                  setView('list');
                  setSelectedPlugin(null);
                  break;
              }
            }}
          />
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  const renderInstallForm = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Install New Plugin</Text>
      </Box>
      
      <Box marginBottom={2}>
        <Text>Plugin name or npm package:</Text>
        <TextInput
          value={installPluginName}
          onChange={setInstallPluginName}
          placeholder="@salesforce/plugin-name or plugin-name"
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Example: @salesforce/plugin-org, @salesforce/plugin-apex, etc.</Text>
      </Box>
      
      <Box flexDirection="column" marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Install', value: 'install' },
            { label: 'Cancel', value: 'cancel' },
          ]}
          onSelect={(item) => {
            if (item.value === 'install' && installPluginName) {
              installPlugin(installPluginName);
            } else {
              setView('list');
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderUninstallConfirmation = () => {
    if (!selectedPlugin) return null;
    
    return (
      <Box flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Uninstall Plugin</Text>
        </Box>
        
        <Box marginBottom={2}>
          <Text>Are you sure you want to uninstall {selectedPlugin.name}?</Text>
          <Text>Version: {selectedPlugin.version}</Text>
        </Box>
        
        <Box flexDirection="column" marginBottom={2}>
          <SelectInput
            items={[
              { label: '✅ Yes, uninstall it', value: 'confirm' },
              { label: '❌ No, keep it', value: 'cancel' },
            ]}
            onSelect={(item) => {
              if (item.value === 'confirm') {
                uninstallPlugin(selectedPlugin.name);
              } else {
                setView('details');
              }
            }}
          />
        </Box>
        
        <Text color="gray" italic>ESC to go back</Text>
      </Box>
    );
  };

  const renderOutput = () => {
    if (!output && !error) return null;
    
    return (
      <Box marginTop={2} flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Output:</Text>
        </Box>
        <Box borderStyle="round" padding={1} height={10} overflow="hidden">
          <Text>{error || output}</Text>
        </Box>
      </Box>
    );
  };

  return (
    <Box flexDirection="column" padding={1}>
      {isProcessing || isCheckingForUpdates ? (
        <Box>
          <Text><Spinner type="dots" /> {isCheckingForUpdates ? 'Checking for updates...' : 'Processing...'}</Text>
        </Box>
      ) : (
        <>
          {view === 'list' && renderPluginList()}
          {view === 'details' && renderPluginDetails()}
          {view === 'install' && renderInstallForm()}
          {view === 'uninstall' && renderUninstallConfirmation()}
          {renderOutput()}
        </>
      )}
    </Box>
  );
};

export default PluginsPanel;
</file>

<file path="src/components/project/ProjectGenerator.tsx">
import React, { useState } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import { TextInput } from '../common/TextInput';

type ProjectManagerProps = {
  onBack: () => void;
};

type ProjectType = 'standard' | 'empty' | 'analytics' | 'functions' | 'lwc' | 'pkg';

const PROJECT_TYPES = [
  {
    label: 'Standard Project',
    value: 'standard',
    description: 'A standard Salesforce project with the default settings',
  },
  {
    label: 'Empty Project',
    value: 'empty',
    description: 'Create an empty Salesforce project',
  },
  {
    label: 'Analytics Project',
    value: 'analytics',
    description: 'A project with Analytics (Wave) templates',
  },
  {
    label: 'Functions Project',
    value: 'functions',
    description: 'A project with Salesforce Functions support',
  },
  {
    label: 'LWC Project',
    value: 'lwc',
    description: 'A project optimized for Lightning Web Components',
  },
  {
    label: 'Package Project',
    value: 'pkg',
    description: 'A project for developing unlocked or managed packages',
  },
];

export const ProjectGenerator = ({ onBack }: ProjectManagerProps) => {
  const [step, setStep] = useState<'type' | 'name' | 'directory' | 'creating'>('type');
  const [projectType, setProjectType] = useState<ProjectType>('standard');
  const [projectName, setProjectName] = useState('my-sfdx-project');
  const [directory, setDirectory] = useState(process.cwd());
  const [output, setOutput] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [createdProjectPath, setCreatedProjectPath] = useState('');

  useInput((input, key) => {
    if (key.escape) {
      if (step === 'type') {
        onBack();
      } else {
        setStep('type');
      }
    }
  });

  const createProject = async () => {
    setIsCreating(true);
    setOutput('');
    
    try {
      const args = ['project', 'generate', '--name', projectName];
      
      // Add project type specific flags
      switch (projectType) {
        case 'empty':
          args.push('--empty');
          break;
        case 'analytics':
          args.push('--template', 'analytics');
          break;
        case 'functions':
          args.push('--template', 'functions');
          break;
        case 'lwc':
          args.push('--template', 'lwc');
          break;
        case 'pkg':
          args.push('--template', 'package');
          break;
        // 'standard' is the default
      }
      
      // Set output directory
      const projectPath = `${directory}/${projectName}`.replace(/\/\//g, '/');
      args.push('--output-dir', directory);
      
      const process = execa('sf', args);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      
      setCreatedProjectPath(projectPath);
      setStep('creating');
    } catch (error) {
      setOutput(`Error: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsCreating(false);
    }
  };

  const renderProjectTypeStep = () => (
    <Box flexDirection="column">
      <Text bold>Select Project Type</Text>
      <Text>Choose the type of Salesforce project you'd like to create:</Text>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={PROJECT_TYPES.map(type => ({
            ...type,
            key: type.value,
          }))}
          onSelect={(item) => {
            setProjectType(item.value as ProjectType);
            setStep('name');
          }}
          itemComponent={({ isSelected, label, description }: { isSelected: boolean, label: string, description: string }) => (
            <Box>
              <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
              <Text>  </Text>
              <Text color="gray">{description}</Text>
            </Box>
          )}
        />
      </Box>
      
      <Text color="gray" italic>Use arrow keys to navigate, Enter to select, ESC to go back</Text>
    </Box>
  );

  const renderProjectNameStep = () => (
    <Box flexDirection="column">
      <Text bold>Project Name</Text>
      <Text>Enter a name for your project (alphanumeric and hyphens only):</Text>
      
      <Box marginTop={1} marginBottom={2}>
        <Text>Project name: </Text>
        <TextInput
          value={projectName}
          onChange={setProjectName}
          onSubmit={() => setStep('directory')}
          validate={(value) => /^[a-zA-Z0-9-]+$/.test(value) || 'Project name can only contain letters, numbers, and hyphens'}
        />
      </Box>
      
      <Text color="gray" italic>Press Enter to continue, ESC to go back</Text>
    </Box>
  );

  const renderDirectoryStep = () => (
    <Box flexDirection="column">
      <Text bold>Project Directory</Text>
      <Text>Where would you like to create the project?</Text>
      
      <Box marginTop={1} marginBottom={1}>
        <Text>Directory: </Text>
        <TextInput
          value={directory}
          onChange={setDirectory}
          onSubmit={createProject}
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Full path: {directory}/{projectName}</Text>
      </Box>
      
      <Box flexDirection="column" marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Create Project', value: 'create' },
            { label: 'Change Project Type', value: 'type' },
            { label: 'Change Project Name', value: 'name' },
            { label: 'Cancel', value: 'cancel' },
          ]}
          onSelect={(item) => {
            switch (item.value) {
              case 'create':
                createProject();
                break;
              case 'type':
                setStep('type');
                break;
              case 'name':
                setStep('name');
                break;
              case 'cancel':
                onBack();
                break;
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderCreatingStep = () => (
    <Box flexDirection="column">
      {isCreating ? (
        <>
          <Text><Spinner type="dots" /> Creating project...</Text>
          <Box marginTop={1} borderStyle="round" padding={1} height={10} overflow="hidden">
            <Text>{output || 'Initializing project...'}</Text>
          </Box>
        </>
      ) : createdProjectPath ? (
        <Box flexDirection="column">
          <Text color="green">✓ Project created successfully!</Text>
          <Newline />
          <Text>Project location: {createdProjectPath}</Text>
          <Newline />
          <Text>Next steps:</Text>
          <Text>  1. <Text color="cyan">cd {createdProjectPath.split('/').pop()}</Text></Text>
          <Text>  2. <Text color="cyan">sft</Text> to open the TUI in your new project</Text>
          <Newline />
          <Text>Press any key to continue...</Text>
        </Box>
      ) : (
        <Box flexDirection="column">
          <Text color="red">Error creating project</Text>
          <Box marginTop={1} borderStyle="round" padding={1} height={10} overflow="hidden">
            <Text>{output || 'Unknown error occurred'}</Text>
          </Box>
          <Newline />
          <Text>Press any key to continue...</Text>
        </Box>
      )}
    </Box>
  );

  return (
    <Box flexDirection="column" padding={1}>
      <Box marginBottom={1}>
        <Text bold>New Salesforce Project</Text>
      </Box>
      
      {step === 'type' && renderProjectTypeStep()}
      {step === 'name' && renderProjectNameStep()}
      {step === 'directory' && renderDirectoryStep()}
      {step === 'creating' && renderCreatingStep()}
      
      {step !== 'creating' && (
        <Text color="gray" italic>
          ESC to go back
        </Text>
      )}
    </Box>
  );
};

export default ProjectGenerator;
</file>

<file path="src/components/run/RunTools.tsx">
import React, { useState } from 'react';
import { Box, Text, useInput, useApp, Newline } from 'ink';
import SelectInput from 'ink-select-input';
import chalk from 'chalk';
import { execa } from 'execa';
import Spinner from 'ink-spinner';
import { TextInput } from '../common/TextInput';

type RunTool = {
  id: string;
  label: string;
  description: string;
  requiresTargetOrg?: boolean;
};

type RunToolsProps = {
  onBack: () => void;
};

const RUN_TOOLS: RunTool[] = [
  {
    id: 'apex',
    label: 'Execute Anonymous Apex',
    description: 'Execute anonymous Apex code',
    requiresTargetOrg: true,
  },
  {
    id: 'flow',
    label: 'Run Flow',
    description: 'Run a Flow or Process Builder flow',
    requiresTargetOrg: true,
  },
  {
    id: 'test',
    label: 'Run Tests',
    description: 'Run Apex tests',
    requiresTargetOrg: true,
  },
  {
    id: 'soql',
    label: 'Execute SOQL Query',
    description: 'Run a SOQL query',
    requiresTargetOrg: true,
  },
  {
    id: 'data-tree',
    label: 'View Data Tree',
    description: 'Explore sObject data relationships',
    requiresTargetOrg: true,
  },
];

export const RunTools = ({ onBack }: RunToolsProps) => {
  const [selectedTool, setSelectedTool] = useState<RunTool | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [output, setOutput] = useState('');
  const [error, setError] = useState('');
  const [targetOrg, setTargetOrg] = useState('');
  const [apexCode, setApexCode] = useState('System.debug(\'Hello from SF TUI!\');');
  const [flowName, setFlowName] = useState('');
  const [soqlQuery, setSoqlQuery] = useState('SELECT Id, Name FROM Account LIMIT 10');
  const [testClasses, setTestClasses] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);

  const runCommand = async (command: string, args: string[] = []) => {
    try {
      setIsProcessing(true);
      setOutput('');
      setError('');
      
      const process = execa('sf', [command, ...args]);
      
      // Stream output
      process.stdout?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      process.stderr?.on('data', (data) => {
        setOutput(prev => prev + data.toString());
      });
      
      await process;
      return true;
    } catch (err) {
      setError(`Error: ${err instanceof Error ? err.message : String(err)}`);
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const handleToolSelect = (tool: RunTool) => {
    setSelectedTool(tool);
  };

  const executeTool = async () => {
    if (!selectedTool) return;
    
    try {
      setIsProcessing(true);
      setOutput('');
      setError('');
      
      let command = 'data';
      const args: string[] = [];
      
      switch (selectedTool.id) {
        case 'apex':
          command = 'apex';
          args.push('run', '--code', `"${apexCode}"`);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'flow':
          command = 'flow';
          args.push('run', '--flow', flowName);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'test':
          command = 'apex';
          args.push('run', 'test');
          if (testClasses) args.push('--class-names', testClasses);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'soql':
          command = 'data';
          args.push('query', '--query', `"${soqlQuery}"`);
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
          
        case 'data-tree':
          command = 'data';
          args.push('tree', 'view');
          if (targetOrg) args.push('--target-org', targetOrg);
          break;
      }
      
      await runCommand(command, args);
    } catch (err) {
      setError(`Failed to execute ${selectedTool.label}: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setIsProcessing(false);
    }
  };

  useInput((input, key) => {
    if (key.escape) {
      if (selectedTool) {
        setSelectedTool(null);
      } else {
        onBack();
      }
    }
  });

  const renderToolList = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Run Tools</Text>
      </Box>
      
      <Box marginBottom={2}>
        <SelectInput
          items={RUN_TOOLS.map(tool => ({
            ...tool,
            label: `${tool.label} - ${tool.description}`,
            value: tool.id,
          }))}
          onSelect={(item) => handleToolSelect(item as unknown as RunTool)}
          itemComponent={({ isSelected, label }) => (
            <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
          )}
        />
      </Box>
      
      <Text color="gray" italic>Use arrow keys to navigate, Enter to select, ESC to go back</Text>
    </Box>
  );

  const renderApexTool = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Execute Anonymous Apex</Text>
      </Box>
      
      <Box marginBottom={1}>
        <Text>Enter your Apex code:</Text>
      </Box>
      
      <Box marginBottom={2} borderStyle="round" padding={1} height={10} overflow="hidden">
        <TextInput
          value={apexCode}
          onChange={setApexCode}
          multiline
          onSubmit={executeTool}
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Target Org: </Text>
        <TextInput
          value={targetOrg}
          onChange={setTargetOrg}
          placeholder="username or alias"
        />
      </Box>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Execute', value: 'run' },
            { label: 'Back to Tools', value: 'back' },
          ]}
          onSelect={(item) => {
            if (item.value === 'run') {
              executeTool();
            } else {
              setSelectedTool(null);
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderFlowTool = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Run Flow</Text>
      </Box>
      
      <Box marginBottom={2}>
        <Text>Flow API Name: </Text>
        <TextInput
          value={flowName}
          onChange={setFlowName}
          placeholder="My_Flow_API_Name"
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Target Org: </Text>
        <TextInput
          value={targetOrg}
          onChange={setTargetOrg}
          placeholder="username or alias"
        />
      </Box>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Run Flow', value: 'run' },
            { label: 'Back to Tools', value: 'back' },
          ]}
          onSelect={(item) => {
            if (item.value === 'run') {
              executeTool();
            } else {
              setSelectedTool(null);
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderTestTool = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Run Apex Tests</Text>
      </Box>
      
      <Box marginBottom={2}>
        <Text>Test Classes (comma-separated, leave empty for all tests):</Text>
        <TextInput
          value={testClasses}
          onChange={setTestClasses}
          placeholder="MyTestClass,AnotherTestClass"
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Target Org: </Text>
        <TextInput
          value={targetOrg}
          onChange={setTargetOrg}
          placeholder="username or alias"
        />
      </Box>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Run Tests', value: 'run' },
            { label: 'Back to Tools', value: 'back' },
          ]}
          onSelect={(item) => {
            if (item.value === 'run') {
              executeTool();
            } else {
              setSelectedTool(null);
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderSoqlTool = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Execute SOQL Query</Text>
      </Box>
      
      <Box marginBottom={1}>
        <Text>Enter your SOQL query:</Text>
      </Box>
      
      <Box marginBottom={2} borderStyle="round" padding={1} height={5} overflow="hidden">
        <TextInput
          value={soqlQuery}
          onChange={setSoqlQuery}
          onSubmit={executeTool}
        />
      </Box>
      
      <Box marginBottom={2}>
        <Text>Target Org: </Text>
        <TextInput
          value={targetOrg}
          onChange={setTargetOrg}
          placeholder="username or alias"
        />
      </Box>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={[
            { label: 'Run Query', value: 'run' },
            { label: 'Back to Tools', value: 'back' },
          ]}
          onSelect={(item) => {
            if (item.value === 'run') {
              executeTool();
            } else {
              setSelectedTool(null);
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderDataTreeTool = () => (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>View Data Tree</Text>
      </Box>
      
      <Box marginBottom={2}>
        <Text>Explore sObject data relationships in your org.</Text>
      </Box>
      
      <Box marginBottom={2}>
        <Text>Target Org: </Text>
        <TextInput
          value={targetOrg}
          onChange={setTargetOrg}
          placeholder="username or alias"
        />
      </Box>
      
      <Box marginTop={1} marginBottom={2}>
        <SelectInput
          items={[
            { label: 'View Data Tree', value: 'run' },
            { label: 'Back to Tools', value: 'back' },
          ]}
          onSelect={(item) => {
            if (item.value === 'run') {
              executeTool();
            } else {
              setSelectedTool(null);
            }
          }}
        />
      </Box>
      
      <Text color="gray" italic>ESC to go back</Text>
    </Box>
  );

  const renderToolForm = () => {
    if (!selectedTool) return null;
    
    switch (selectedTool.id) {
      case 'apex':
        return renderApexTool();
      case 'flow':
        return renderFlowTool();
      case 'test':
        return renderTestTool();
      case 'soql':
        return renderSoqlTool();
      case 'data-tree':
        return renderDataTreeTool();
      default:
        return null;
    }
  };

  const renderOutput = () => {
    if (!output && !error) return null;
    
    return (
      <Box marginTop={2} flexDirection="column">
        <Box marginBottom={1}>
          <Text bold>Output:</Text>
        </Box>
        <Box borderStyle="round" padding={1} height={10} overflow="hidden">
          <Text>{error || output}</Text>
        </Box>
      </Box>
    );
  };

  return (
    <Box flexDirection="column" padding={1}>
      {isProcessing ? (
        <Box>
          <Text><Spinner type="dots" /> Processing...</Text>
        </Box>
      ) : selectedTool ? (
        <>
          {renderToolForm()}
          {renderOutput()}
        </>
      ) : (
        renderToolList()
      )}
    </Box>
  );
};

export default RunTools;
</file>

<file path="src/components/MainMenu.tsx">
import React, { useState } from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import SelectInput, { SelectInputItem } from 'ink-select-input';
import chalk from 'chalk';
// Import our custom types
import '../types/ink-components';
import { OrgManager } from './org/OrgManager';
import { ProjectGenerator } from './project/ProjectGenerator';
import { AliasManager } from './alias/AliasManager';
import { AuthManager } from './auth/AuthManager';
import { MetadataTools } from './metadata/MetadataTools';
import { RunTools } from './run/RunTools';
import { PluginsPanel } from './plugins/PluginsPanel';
import { ErrorProvider, ErrorBoundary } from './common';

// Extend the SelectInputItem type to include our custom properties
interface MenuItem extends SelectInputItem<string> {
  label: string;
  value: string;
  description: string;
}

const menuItems: MenuItem[] = [
  {
    label: '🔄  Org Manager',
    value: 'org',
    description: 'Manage your Salesforce orgs (scratch, sandbox, production)'
  },
  {
    label: '🚀  Project Generator',
    value: 'project',
    description: 'Create new Salesforce projects and packages'
  },
  {
    label: '🔑  Auth Manager',
    value: 'auth',
    description: 'Authenticate with Salesforce orgs'
  },
  {
    label: '🏷️  Alias Manager',
    value: 'alias',
    description: 'Manage your Salesforce CLI aliases'
  },
  {
    label: '📦  Metadata Tools',
    value: 'metadata',
    description: 'Deploy, retrieve, and manage metadata'
  },
  {
    label: '⚡  Run Tools',
    value: 'run',
    description: 'Run Apex, Flows, and more'
  },
  {
    label: '🧩  Plugins',
    value: 'plugins',
    description: 'Manage CLI plugins'
  },
  {
    label: '❌  Exit',
    value: 'exit',
    description: 'Exit SF TUI'
  },
];

export const MainMenu = () => {
  const [selectedItem, setSelectedItem] = useState<string | null>(null);
  const { exit } = useApp();

  const renderHeader = () => (
    <Box flexDirection="column" marginBottom={1}>
      <Text bold color="cyan">
        {chalk.bold.cyanBright('┌─┐┌┐┌┌─┐┬  ┬  ┌─┐┬─┐')}
      </Text>
      <Text bold color="cyan">
        {chalk.bold.cyanBright('└─┐││││ ││  │  ├┤ ├┬┘')}
      </Text>
      <Text bold color="cyan">
        {chalk.bold.cyanBright('└─┘┘└┘└─┘┴─┘┴─┘└─┘┴└─')}
      </Text>
      <Text color="gray" italic>Salesforce TUI - Interactive CLI for Salesforce</Text>
      <Text color="gray" italic>v1.0.0</Text>
      <Text> </Text>
    </Box>
  );

  const renderContent = () => {
    if (!selectedItem) {
      return (
        <Box flexDirection="column">
          <Text bold>What would you like to do?</Text>
          <SelectInput
            items={menuItems}
            onSelect={(item) => {
              if (item.value === 'exit') {
                exit();
                return;
              }
              setSelectedItem(item.value);
            }}
            itemComponent={({ isSelected, label, value }: { isSelected: boolean, label: string, value: string }) => {
              // Find the menu item to get its description
              const item = menuItems.find(item => item.value === value);
              return (
                <Box>
                  <Text color={isSelected ? 'cyan' : 'white'}>{label}</Text>
                  <Text>  </Text>
                  <Text color="gray">{item?.description}</Text>
                </Box>
              );
            }}
          />
        </Box>
      );
    }

    // Render the selected component
    switch (selectedItem) {
      case 'org':
        return <OrgManager onBack={() => setSelectedItem(null)} />;
      case 'project':
        return <ProjectGenerator onBack={() => setSelectedItem(null)} />;
      case 'auth':
        return <AuthManager onBack={() => setSelectedItem(null)} />;
      case 'alias':
        return <AliasManager onBack={() => setSelectedItem(null)} />;
      case 'metadata':
        return <MetadataTools onBack={() => setSelectedItem(null)} />;
      case 'run':
        return <RunTools onBack={() => setSelectedItem(null)} />;
      case 'plugins':
        return <PluginsPanel onBack={() => setSelectedItem(null)} />;
      default:
        return null;
    }
  };

  return (
    <ErrorProvider position="top" maxVisibleErrors={2}>
      <ErrorBoundary componentName="MainMenu">
        <Box flexDirection="column" padding={1}>
          {renderHeader()}
          {renderContent()}
          <Text> </Text>
          <Text color="gray" italic>
            Use arrow keys to navigate, Enter to select, Esc to go back
          </Text>
        </Box>
      </ErrorBoundary>
    </ErrorProvider>
  );
};

export default MainMenu;
</file>

<file path="src/config/index.ts">
import fs from 'fs';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import { deepMerge } from '../utils/helpers';
import { Theme } from '../themes';

// Get the directory name in ES module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Default configuration
export interface Config {
  theme: string;
  editor: string;
  defaultOrg?: string;
  apiVersion: string;
  plugins: string[];
  telemetry: boolean;
  experimental: {
    features: string[];
  };
  [key: string]: any;
}

const defaultConfig: Config = {
  theme: 'salesforce',
  editor: process.env.EDITOR || 'code',
  defaultOrg: undefined,
  apiVersion: '58.0',
  plugins: [],
  telemetry: true,
  experimental: {
    features: [],
  },
};

// Path to the config file
const CONFIG_DIR = path.join(os.homedir(), '.sftui');
const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');

// Ensure config directory exists
const ensureConfigDir = () => {
  if (!fs.existsSync(CONFIG_DIR)) {
    fs.mkdirSync(CONFIG_DIR, { recursive: true });
  }
};

// Load configuration from file
const loadConfig = (): Config => {
  try {
    ensureConfigDir();
    
    if (fs.existsSync(CONFIG_FILE)) {
      const configData = fs.readFileSync(CONFIG_FILE, 'utf8');
      return deepMerge({ ...defaultConfig }, JSON.parse(configData));
    }
    
    // If no config file exists, create one with defaults
    saveConfig(defaultConfig);
    return { ...defaultConfig };
  } catch (error) {
    console.error('Error loading configuration:', error);
    return { ...defaultConfig };
  }
};

// Save configuration to file
const saveConfig = (config: Partial<Config>): void => {
  try {
    ensureConfigDir();
    const currentConfig = loadConfig();
    const newConfig = deepMerge(currentConfig, config);
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(newConfig, null, 2), 'utf8');
  } catch (error) {
    console.error('Error saving configuration:', error);
  }
};

// Get a configuration value
const getConfig = <T = any>(key?: string): T => {
  const config = loadConfig();
  return key ? config[key] : (config as any);
};

// Set a configuration value
const setConfig = (key: string, value: any): void => {
  const config = loadConfig();
  const newConfig = { ...config, [key]: value };
  saveConfig(newConfig);
};

// Reset configuration to defaults
const resetConfig = (): void => {
  saveConfig(defaultConfig);
};

// Get theme configuration
const getTheme = (themeName?: string): Theme => {
  const theme = themeName || getConfig<string>('theme');
  return require('../themes').getTheme(theme);
};

// Export configuration methods
export const config = {
  get: getConfig,
  set: setConfig,
  reset: resetConfig,
  getTheme,
  get path() {
    return CONFIG_FILE;
  },
  get dir() {
    return CONFIG_DIR;
  },
};

// Initialize default configuration if it doesn't exist
ensureConfigDir();
if (!fs.existsSync(CONFIG_FILE)) {
  saveConfig(defaultConfig);
}

export default config;
</file>

<file path="src/hooks/index.ts">
/**
 * Re-export all hooks from this file
 */

export * from './useMeasure';
export * from './useNodeSelection';
// Export other hooks here as we create them
</file>

<file path="src/hooks/useMeasure.ts">
import { useState, useRef, useLayoutEffect } from 'react';

type Dimensions = {
  width: number;
  height: number;
  top: number;
  left: number;
  right: number;
  bottom: number;
  x: number;
  y: number;
};

const defaultDims: Dimensions = {
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  x: 0,
  y: 0,
};

/**
 * A hook to measure the dimensions of a DOM element
 * @param deps Dependencies that should trigger a re-measure
 * @returns An array containing a ref to attach to the element and its dimensions
 */
const useMeasure = <T extends HTMLElement = HTMLDivElement>(
  deps: React.DependencyList = []
): [React.RefObject<T>, Dimensions] => {
  const [dimensions, setDimensions] = useState<Dimensions>(defaultDims);
  const ref = useRef<T>(null);

  useLayoutEffect(() => {
    if (!ref.current) return;

    const measure = () => {
      if (!ref.current) return;

      const rect = ref.current.getBoundingClientRect();
      
      setDimensions({
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        right: rect.right,
        bottom: rect.bottom,
        x: rect.x,
        y: rect.y,
      });
    };

    // Initial measurement
    measure();

    // Set up resize observer for responsive elements
    // Polyfill for ResizeObserver might be needed in some environments
    if (typeof ResizeObserver !== 'undefined') {
      const resizeObserver = new ResizeObserver(measure);
      if (ref.current) {
        resizeObserver.observe(ref.current);
      }

      // Clean up
      return () => {
        if (ref.current) {
          resizeObserver.unobserve(ref.current);
        }
        resizeObserver.disconnect();
      };
    }
    
    // Return empty cleanup function if ResizeObserver is not available
    return () => {};
  }, [ref, ...deps]);

  return [ref, dimensions];
};

export { useMeasure };
</file>

<file path="src/hooks/useNodeSelection.ts">
import { useInput } from 'ink';
import { useCallback, useRef } from 'react';

/**
 * Custom hook to handle node selection in tree views and similar components
 * Since Ink doesn't support onClick directly, we use useInput to simulate selection
 */
export const useNodeSelection = <T>(
  isFocused: boolean,
  onSelect: (item: T) => void,
  item: T
) => {
  // Track if this node is the currently focused one
  const nodeRef = useRef({ isFocused });

  // Update the ref when focus changes
  nodeRef.current.isFocused = isFocused;

  // Set up input handler
  useInput(
    useCallback(
      (input, key) => {
        // Only handle enter key presses for the focused node
        if (nodeRef.current.isFocused && key.return) {
          onSelect(item);
          return true;
        }
        return false;
      },
      [item, onSelect]
    ),
    { isActive: isFocused }
  );

  return {
    // Return any properties or handlers needed
    ref: nodeRef,
  };
};
</file>

<file path="src/themes/index.ts">
import * as React from 'react';
import { Theme as ThemeType } from '../types/theme';

// Re-export the Theme type
export type Theme = ThemeType;

// Base theme with default colors and styles
export const baseTheme: Theme = {
  colors: {
    primary: '#36A9E1', // Salesforce blue
    secondary: '#2E844A', // Salesforce green
    success: '#2E844A', // Green
    warning: '#FE9339', // Orange
    error: '#EA001E', // Red
    info: '#0176D3', // Blue
    text: '#181818', // Dark gray (almost black)
    textInverse: '#FFFFFF', // White
    textMuted: '#706E6B', // Medium gray
    background: '#FFFFFF', // White
    backgroundHover: '#F3F3F3', // Light gray
    border: '#DDDBDA', // Light gray
    highlight: '#F3F2F2', // Very light gray
  },
  spacing: {
    xs: 1,
    sm: 2,
    md: 4,
    lg: 8,
    xl: 16,
  },
  borderRadius: {
    sm: 2,
    md: 4,
    lg: 8,
  },
  box: {
    borderStyle: 'round',
    padding: 1,
    margin: 1,
  },
  text: {
    bold: (isActive = true) => ({
      bold: isActive,
    }),
    italic: (isActive = true) => ({
      italic: isActive,
    }),
    underline: (isActive = true) => ({
      underline: isActive,
    }),
    dim: (isActive = true) => ({
      dimColor: isActive,
    }),
    color: (color: string) => ({
      color,
    }),
    bgColor: (color: string) => ({
      backgroundColor: color,
    }),
  },
};

// Dark theme
export const darkTheme: Theme = {
  ...baseTheme,
  colors: {
    ...baseTheme.colors,
    text: '#F3F3F3', // Light gray
    textInverse: '#181818', // Dark gray (almost black)
    textMuted: '#B0ADAB', // Medium-light gray
    background: '#1B1B1B', // Dark gray
    backgroundHover: '#2D2D2D', // Slightly lighter dark gray
    border: '#444444', // Medium-dark gray
    highlight: '#333333', // Dark gray highlight
  },
};

// High contrast theme for better accessibility
export const highContrastTheme: Theme = {
  ...baseTheme,
  colors: {
    primary: '#0067B8', // Darker blue
    secondary: '#0A7C36', // Darker green
    success: '#0A7C36', // Darker green
    warning: '#D83B01', // Darker orange
    error: '#A91B0A', // Darker red
    info: '#0050B3', // Darker blue
    text: '#000000', // Black
    textInverse: '#FFFFFF', // White
    textMuted: '#4D4D4D', // Dark gray
    background: '#FFFFFF', // White
    backgroundHover: '#E5E5E5', // Light gray
    border: '#000000', // Black
    highlight: '#F0F0F0', // Very light gray
  },
};

// Salesforce Lightning theme
export const salesforceTheme: Theme = {
  ...baseTheme,
  colors: {
    primary: '#0176D3', // Salesforce blue
    secondary: '#2E844A', // Salesforce green
    success: '#2E844A', // Green
    warning: '#FE9339', // Orange
    error: '#EA001E', // Red
    info: '#0176D3', // Blue
    text: '#181818', // Dark gray (almost black)
    textInverse: '#FFFFFF', // White
    textMuted: '#706E6B', // Medium gray
    background: '#F3F3F3', // Light gray
    backgroundHover: '#E5E5E5', // Slightly darker gray
    border: '#C9C9C9', // Medium-light gray
    highlight: '#E5E5E5', // Light gray
  },
};

// Get theme by name
export const getTheme = (themeName: string = 'base'): Theme => {
  switch (themeName.toLowerCase()) {
    case 'dark':
      return darkTheme;
    case 'highcontrast':
    case 'high-contrast':
    case 'highContrast':
      return highContrastTheme;
    case 'salesforce':
    case 'lightning':
      return salesforceTheme;
    case 'base':
    default:
      return baseTheme;
  }
};

// Theme context for React components
export const ThemeContext = React.createContext<Theme>(baseTheme);

// Theme provider component
export const ThemeProvider: React.FC<{ theme?: Theme; children: React.ReactNode }> = ({
  theme = baseTheme,
  children,
}) => {
  return React.createElement(ThemeContext.Provider, { value: theme }, children);
};

// Hook to use the current theme
export const useTheme = (): Theme => {
  const theme = React.useContext(ThemeContext);
  return theme || baseTheme;
};
</file>

<file path="src/types/ink-components.d.ts">
import React, { ReactNode } from 'react';

// Common prop types that all Ink components might need
export interface CommonProps {
  style?: React.CSSProperties;
  onClick?: () => void;
  onMouseEnter?: () => void;
  onMouseLeave?: () => void;
  onFocus?: () => void;
  onBlur?: () => void;
}

// Type definitions for ink-select-input
declare module 'ink-select-input' {
  export interface SelectInputItem<V = any> {
    label: string;
    value: V;
    [key: string]: any;
  }

  export interface Props {
    isSelected: boolean;
    label: string;
    [key: string]: any;
  }

  export interface SelectInputProps<V = any> {
    items: SelectInputItem<V>[];
    onSelect: (item: SelectInputItem<V>) => void;
    onHighlight?: (item: SelectInputItem<V>) => void;
    initialIndex?: number;
    indicatorComponent?: React.ReactNode;
    itemComponent?: React.FC<{
      isSelected: boolean;
      label: string;
      [key: string]: any;
    }>;
    limit?: number;
  }

  const SelectInput: React.FC<SelectInputProps>;
  export default SelectInput;
}

// Type definitions for ink components
declare module 'ink' {
  export interface BoxProps extends CommonProps {
    borderStyle?: 'single' | 'double' | 'round' | 'bold' | 'singleDouble' | 'doubleSingle' | 'classic' | 'none';
    borderColor?: string;
    borderTop?: boolean | string;
    borderBottom?: boolean | string;
    borderLeft?: boolean | string;
    borderRight?: boolean | string;
    borderTopStyle?: string;
    borderBottomStyle?: string;
    borderLeftStyle?: string;
    borderRightStyle?: string;
    flexDirection?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
    flexGrow?: number;
    flexShrink?: number;
    flexBasis?: number | string;
    flex?: number | string;
    alignItems?: 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline';
    alignSelf?: 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline';
    justifyContent?: 'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-around';
    width?: number | string;
    height?: number | string;
    minWidth?: number | string;
    minHeight?: number | string;
    maxWidth?: number | string;
    maxHeight?: number | string;
    padding?: number | string;
    paddingTop?: number | string;
    paddingBottom?: number | string;
    paddingLeft?: number | string;
    paddingRight?: number | string;
    paddingX?: number;
    paddingY?: number;
    margin?: number | string;
    marginTop?: number | string;
    marginBottom?: number | string;
    marginLeft?: number | string;
    marginRight?: number | string;
    marginX?: number;
    marginY?: number;
    position?: 'absolute' | 'relative' | 'fixed';
    overflow?: 'visible' | 'hidden' | 'scroll' | 'auto';
    gap?: number;
    columnGap?: number;
    rowGap?: number;
    tabIndex?: number;
    ref?: React.Ref<any>;
    children?: ReactNode;
  }

  export interface TextProps extends CommonProps {
    color?: string;
    backgroundColor?: string;
    dimColor?: boolean;
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
    strikethrough?: boolean;
    inverse?: boolean;
    wrap?: 'wrap' | 'truncate' | 'truncate-start' | 'truncate-middle' | 'truncate-end';
    className?: string;
    children?: ReactNode;
  }

  export interface AppProps {
    children: ReactNode;
    onExit?: () => void;
  }

  export const Box: React.FC<BoxProps>;
  export const Text: React.FC<TextProps>;
  export const useApp: () => { exit: (error?: Error) => void };
  export const useFocus: (options?: { autoFocus?: boolean, isActive?: boolean }) => { isFocused: boolean };
  export const useInput: (
    inputHandler: (input: string, key: {
      upArrow: boolean;
      downArrow: boolean;
      leftArrow: boolean;
      rightArrow: boolean;
      return: boolean;
      escape: boolean;
      ctrl: boolean;
      shift: boolean;
      tab: boolean;
      backspace: boolean;
      delete: boolean;
      meta: boolean;
    }) => void,
    options?: { isActive?: boolean }
  ) => void;
}

// Type definitions for ink-text-input
declare module 'ink-text-input' {
  export interface TextInputProps {
    value: string;
    onChange: (value: string) => void;
    placeholder?: string;
    focus?: boolean;
    mask?: string;
    highlightPastedText?: boolean;
    showCursor?: boolean;
    onSubmit?: (value: string) => void;
    children?: ReactNode;
  }

  const TextInput: React.FC<TextInputProps>;
  export default TextInput;
}

// Type definitions for ink-spinner
declare module 'ink-spinner' {
  export interface SpinnerProps {
    type?: string;
  }

  const Spinner: React.FC<SpinnerProps>;
  export default Spinner;
}

// Extend ink-box for our custom version
declare module 'ink-box' {
  export interface BoxProps {
    borderStyle?: 'single' | 'double' | 'round' | 'bold' | 'singleDouble' | 'doubleSingle' | 'classic';
    borderColor?: string;
    backgroundColor?: string;
    float?: 'left' | 'right' | 'center';
    padding?: number | [number, number] | [number, number, number, number];
    margin?: number | [number, number] | [number, number, number, number];
    title?: string;
    width?: number | string;
    height?: number | string;
    dimBorder?: boolean;
    children?: ReactNode;
  }

  const Box: React.FC<BoxProps>;
  export default Box;
}
</file>

<file path="src/types/theme.ts">
import { TextProps } from 'ink';

export interface ThemeColors {
  primary: string;
  secondary: string;
  success: string;
  warning: string;
  error: string;
  info: string;
  text: string;
  textInverse: string;
  textMuted: string;
  background: string;
  backgroundHover: string;
  border: string;
  highlight: string;
  [key: string]: string; // Allow additional color keys
}

export interface ThemeSpacing {
  xs: number;
  sm: number;
  md: number;
  lg: number;
  xl: number;
  [key: string]: number; // Allow additional spacing keys
}

export interface ThemeBorderRadius {
  sm: number;
  md: number;
  lg: number;
  [key: string]: number; // Allow additional radius keys
}

export interface ThemeBox {
  borderStyle: 'single' | 'double' | 'round' | 'single-double' | 'double-single' | 'classic' | 'none';
  padding: number;
  margin: number;
  [key: string]: any; // Allow additional box styles
}

export interface ThemeText {
  bold: (isActive?: boolean) => Partial<TextProps>;
  italic: (isActive?: boolean) => Partial<TextProps>;
  underline: (isActive?: boolean) => Partial<TextProps>;
  dim: (isActive?: boolean) => Partial<TextProps>;
  color: (color: string) => Partial<TextProps>;
  bgColor: (color: string) => Partial<TextProps>;
  [key: string]: any; // Allow additional text utilities
}

export interface Theme {
  colors: ThemeColors;
  spacing: ThemeSpacing;
  borderRadius: ThemeBorderRadius;
  box: ThemeBox;
  text: ThemeText;
  [key: string]: any; // Allow additional theme properties
}

// Text style presets
export interface TextPresets {
  heading: Partial<TextProps>;
  subheading: Partial<TextProps>;
  body: Partial<TextProps>;
  label: Partial<TextProps>;
  caption: Partial<TextProps>;
  button: Partial<TextProps>;
  link: Partial<TextProps>;
  success: Partial<TextProps>;
  warning: Partial<TextProps>;
  error: Partial<TextProps>;
  info: Partial<TextProps>;
  [key: string]: Partial<TextProps>;
}

// Component styles
export interface ComponentStyles {
  button: {
    primary: Partial<TextProps>;
    secondary: Partial<TextProps>;
    success: Partial<TextProps>;
    warning: Partial<TextProps>;
    error: Partial<TextProps>;
    disabled: Partial<TextProps>;
    [key: string]: Partial<TextProps>;
  };
  input: {
    default: Partial<TextProps>;
    focused: Partial<TextProps>;
    disabled: Partial<TextProps>;
    error: Partial<TextProps>;
    [key: string]: Partial<TextProps>;
  };
  [key: string]: any; // Allow additional component styles
}
</file>

<file path="src/utils/errorReporter.ts">
import { logger, LogLevel } from './logger';

// Define error severity levels
export enum ErrorSeverity {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL',
}

// Define error categories
export enum ErrorCategory {
  UI = 'UI',
  NETWORK = 'NETWORK',
  FILESYSTEM = 'FILESYSTEM',
  COMMAND = 'COMMAND',
  AUTH = 'AUTH',
  PLUGIN = 'PLUGIN',
  VALIDATION = 'VALIDATION',
  UNKNOWN = 'UNKNOWN',
}

// Define error report interface
export interface ErrorReport {
  id: string;
  timestamp: Date;
  message: string;
  error?: Error;
  severity: ErrorSeverity;
  category: ErrorCategory;
  context?: string;
  details?: Record<string, any>;
  userAction?: string;
  handled: boolean;
}

// Define user feedback interface
export interface UserFeedback {
  errorId: string;
  timestamp: Date;
  description: string;
  reproduce?: string;
  contact?: string;
}

// Define subscribers for error notifications
type ErrorReporterSubscriber = (error: ErrorReport) => void;

class ErrorReporter {
  private static instance: ErrorReporter;
  private errors: Map<string, ErrorReport> = new Map();
  private subscribers: ErrorReporterSubscriber[] = [];
  private generateErrorId = (): string => `error-${Date.now()}-${Math.floor(Math.random() * 10000)}`;

  private constructor() {}

  public static getInstance(): ErrorReporter {
    if (!ErrorReporter.instance) {
      ErrorReporter.instance = new ErrorReporter();
    }
    return ErrorReporter.instance;
  }

  // Subscribe to error notifications
  public subscribe(callback: ErrorReporterSubscriber): () => void {
    this.subscribers.push(callback);
    
    // Return unsubscribe function
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }

  // Notify all subscribers of an error
  private notifySubscribers(error: ErrorReport): void {
    for (const subscriber of this.subscribers) {
      try {
        subscriber(error);
      } catch (err) {
        logger.error('Error in error subscriber', { subscriberError: err });
      }
    }
  }

  // Map severity to log level
  private severityToLogLevel(severity: ErrorSeverity): LogLevel {
    switch (severity) {
      case ErrorSeverity.LOW:
        return LogLevel.INFO;
      case ErrorSeverity.MEDIUM:
        return LogLevel.WARN;
      case ErrorSeverity.HIGH:
      case ErrorSeverity.CRITICAL:
        return LogLevel.ERROR;
      default:
        return LogLevel.ERROR;
    }
  }

  // Report a new error
  public reportError(
    message: string,
    errorOrOptions?: Error | {
      error?: Error,
      severity?: ErrorSeverity,
      category?: ErrorCategory,
      context?: string,
      details?: Record<string, any>,
      userAction?: string,
    }
  ): ErrorReport {
    // Handle the case where the second parameter is an Error object
    let error: Error | undefined;
    let severity = ErrorSeverity.MEDIUM;
    let category = ErrorCategory.UNKNOWN;
    let context: string | undefined;
    let details: Record<string, any> | undefined;
    let userAction: string | undefined;
    
    if (errorOrOptions instanceof Error) {
      error = errorOrOptions;
    } else if (errorOrOptions) {
      error = errorOrOptions.error;
      severity = errorOrOptions.severity || severity;
      category = errorOrOptions.category || category;
      context = errorOrOptions.context;
      details = errorOrOptions.details;
      userAction = errorOrOptions.userAction;
    }
    
    // Create the error report
    const report: ErrorReport = {
      id: this.generateErrorId(),
      timestamp: new Date(),
      message,
      error,
      severity,
      category,
      context,
      details,
      userAction,
      handled: false,
    };
    
    // Store the error
    this.errors.set(report.id, report);
    
    // Log the error
    const logLevel = this.severityToLogLevel(severity);
    const logMessage = context ? `[${context}] ${message}` : message;
    const logDetails = {
      ...details,
      errorId: report.id,
      category,
      severity,
    };
    
    logger.log(logLevel, logMessage, logDetails, error);
    
    // Notify subscribers
    this.notifySubscribers(report);
    
    return report;
  }

  // Mark an error as handled
  public markAsHandled(errorId: string): void {
    const error = this.errors.get(errorId);
    if (error) {
      error.handled = true;
      this.errors.set(errorId, error);
    }
  }

  // Get all errors
  public getAllErrors(): ErrorReport[] {
    return Array.from(this.errors.values());
  }

  // Get a specific error by ID
  public getError(errorId: string): ErrorReport | undefined {
    return this.errors.get(errorId);
  }

  // Clear all errors
  public clearErrors(): void {
    this.errors.clear();
  }

  // Submit user feedback for an error
  public submitFeedback(feedback: UserFeedback): void {
    // In a real implementation, this would send the feedback to a server
    // For now, we'll just log it
    logger.info(`User feedback received for error ${feedback.errorId}`, { feedback });
  }

  // Helper methods for common error categories
  public reportCommandError(message: string, error?: Error, details?: Record<string, any>): ErrorReport {
    return this.reportError(message, {
      error,
      severity: ErrorSeverity.MEDIUM,
      category: ErrorCategory.COMMAND,
      details,
      userAction: 'Try running the command again or check the command arguments.',
    });
  }

  public reportNetworkError(message: string, error?: Error, details?: Record<string, any>): ErrorReport {
    return this.reportError(message, {
      error,
      severity: ErrorSeverity.MEDIUM,
      category: ErrorCategory.NETWORK,
      details,
      userAction: 'Check your internet connection and try again.',
    });
  }

  public reportAuthError(message: string, error?: Error, details?: Record<string, any>): ErrorReport {
    return this.reportError(message, {
      error,
      severity: ErrorSeverity.HIGH,
      category: ErrorCategory.AUTH,
      details,
      userAction: 'Try logging in again using sf org login web.',
    });
  }

  public reportValidationError(message: string, error?: Error, details?: Record<string, any>): ErrorReport {
    return this.reportError(message, {
      error,
      severity: ErrorSeverity.LOW,
      category: ErrorCategory.VALIDATION,
      details,
      userAction: 'Check your input values and try again.',
    });
  }
}

// Export a singleton instance
export const errorReporter = ErrorReporter.getInstance();

// Global error handler for uncaught exceptions
export function setupGlobalErrorHandlers(): void {
  // Handle uncaught exceptions
  process.on('uncaughtException', (error) => {
    errorReporter.reportError('Uncaught exception', {
      error,
      severity: ErrorSeverity.CRITICAL,
      category: ErrorCategory.UNKNOWN,
      userAction: 'Please report this issue to the developers.',
    });
    
    // Log the error and exit gracefully
    logger.fatal('Uncaught exception', { error });
    process.exit(1);
  });

  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason, promise) => {
    const error = reason instanceof Error ? reason : new Error(String(reason));
    
    errorReporter.reportError('Unhandled promise rejection', {
      error,
      severity: ErrorSeverity.HIGH,
      category: ErrorCategory.UNKNOWN,
      userAction: 'Please report this issue to the developers.',
    });
    
    // Log the error but don't exit
    logger.error('Unhandled promise rejection', { error });
  });
}
</file>

<file path="src/utils/helpers.ts">
import { execa, ExecaChildProcess } from 'execa';
import chalk from 'chalk';
import { TextProps } from 'ink';
import { logger, handleError } from './logger';

// Custom Spinner type that includes the methods we need
interface SpinnerInterface {
  start: (text: string) => SpinnerInterface;
  stop: () => SpinnerInterface;
  succeed: (text?: string) => SpinnerInterface;
  fail: (text?: string) => SpinnerInterface;
  warn: (text?: string) => SpinnerInterface;
  info: (text: string) => SpinnerInterface;
  render: (frame: number) => void;
  text: string;
  stopAndPersist?: (options?: any) => SpinnerInterface;
}

type Spinner = SpinnerInterface;

type CommandOptions = {
  cwd?: string;
  silent?: boolean;
  spinner?: Spinner;
  env?: NodeJS.ProcessEnv;
  timeout?: number;
};

type CommandResult = {
  stdout: string;
  stderr: string;
  exitCode: number;
  command: string;
};

/**
 * Execute a shell command and return the result
 */
export const executeCommand = async (
  command: string,
  args: string[] = [],
  options: CommandOptions = {}
): Promise<CommandResult> => {
  const { cwd = process.cwd(), silent = false, spinner, env, timeout } = options;
  
  if (!silent) {
    const displayCommand = [command, ...args].join(' ');
    spinner?.start(chalk.dim(`$ ${displayCommand}`));
  }
  
  try {
    // Log command execution
    logger.debug(`Executing command: ${command} ${args.join(' ')}`, { cwd, timeout });
    
    const subprocess = execa(command, args, {
      cwd,
      shell: true,
      env: { ...process.env, ...env, FORCE_COLOR: '1' },
      timeout,
    });
    
    // Stream output if not silent
    if (!silent) {
      subprocess.stdout?.on('data', (data) => {
        const output = data.toString().trim();
        spinner?.stopAndPersist({
          symbol: ' ', 
          text: chalk.dim(output)
        });
        logger.debug(`[stdout] ${output}`);
      });
      
      subprocess.stderr?.on('data', (data) => {
        const output = data.toString().trim();
        spinner?.stopAndPersist({
          symbol: chalk.yellow('!'),
          text: chalk.yellow(output)
        });
        logger.warn(`[stderr] ${output}`);
      });
    }
    
    const result = await subprocess;
    
    if (!silent && spinner) {
      spinner.succeed();
    }
    
    // Log successful completion
    logger.debug(`Command completed successfully: ${command}`, {
      exitCode: 0,
      command: [command, ...args].join(' ')
    });
    
    return {
      stdout: result.stdout,
      stderr: result.stderr,
      exitCode: 0, // execa throws on non-zero exit codes
      command: [command, ...args].join(' '),
    };
  } catch (error: any) {
    // Log the error
    handleError(error, 'executeCommand', {
      command: [command, ...args].join(' '),
      cwd,
      exitCode: error.exitCode || 1
    });
    
    if (!silent && spinner) {
      spinner.fail(chalk.red(`Command failed: ${error.shortMessage || error.message}`));
    }
    
    return {
      stdout: error.stdout || '',
      stderr: error.stderr || error.message,
      exitCode: error.exitCode || 1,
      command: [command, ...args].join(' '),
    };
  }
};

/**
 * Format bytes to human-readable string
 */
export const formatBytes = (bytes: number, decimals = 2): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

/**
 * Format a duration in milliseconds to a human-readable string
 */
export const formatDuration = (ms: number): string => {
  if (ms < 1000) {
    return `${ms}ms`;
  }
  
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
  
  const parts = [];
  
  if (hours > 0) parts.push(`${hours}h`);
  if (minutes > 0) parts.push(`${minutes}m`);
  if (seconds > 0) parts.push(`${seconds}s`);
  
  return parts.join(' ') || '0s';
};

/**
 * Truncate text with ellipsis
 */
export const truncate = (text: string, maxLength: number, ellipsis = '…'): string => {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - ellipsis.length) + ellipsis;
};

/**
 * Create a debounced function
 */
export const debounce = <F extends (...args: any[]) => any>(
  func: F,
  wait: number
): ((...args: Parameters<F>) => void) => {
  let timeout: NodeJS.Timeout;
  
  return function(...args: Parameters<F>) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

/**
 * Create a throttled function
 */
export const throttle = <F extends (...args: any[]) => any>(
  func: F,
  limit: number
): ((...args: Parameters<F>) => void) => {
  let inThrottle = false;
  
  return function(...args: Parameters<F>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

/**
 * Deep merge objects
 */
export const deepMerge = <T extends Record<string, any>>(target: T, source: any): T => {
  const output = { ...target };
  
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key as keyof T] = deepMerge(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  
  return output;
};

/**
 * Check if value is an object
 */
export const isObject = (item: any): item is Record<string, any> => {
  return item !== null && typeof item === 'object' && !Array.isArray(item);
};

/**
 * Generate a random ID
 */
export const generateId = (length = 8): string => {
  return Math.random().toString(36).substring(2, 2 + length);
};

/**
 * Format text with chalk based on props
 */
export const formatText = (text: string, props: TextProps = {}): string => {
  let result = text;
  
  if (props.color) {
    result = chalk.hex(props.color)(result);
  }
  
  if (props.backgroundColor) {
    result = chalk.bgHex(props.backgroundColor)(result);
  }
  
  if (props.bold) {
    result = chalk.bold(result);
  }
  
  if (props.italic) {
    result = chalk.italic(result);
  }
  
  if (props.underline) {
    result = chalk.underline(result);
  }
  
  if (props.dimColor) {
    result = chalk.dim(result);
  }
  
  if (props.inverse) {
    result = chalk.inverse(result);
  }
  
  if (props.strikethrough) {
    result = chalk.strikethrough(result);
  }
  
  return result;
};

/**
 * Create a loading spinner
 */
export const createSpinner = (text: string, spinnerType = 'dots'): Spinner => {
  const spinner = {
    interval: 80,
    frames: [
      '⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'
    ],
    text: '',
    start(text: string) {
      this.text = text;
      this.render(0);
      return this;
    },
    stop() {
      process.stdout.write('\r' + ' '.repeat(process.stdout.columns || 80) + '\r');
      return this;
    },
    succeed(text?: string) {
      this.stop();
      console.log(chalk.green('✓') + ' ' + (text || this.text));
      return this;
    },
    fail(text?: string) {
      this.stop();
      console.error(chalk.red('✗') + ' ' + (text || this.text));
      return this;
    },
    warn(text?: string) {
      this.stop();
      console.warn(chalk.yellow('!') + ' ' + (text || this.text));
      return this;
    },
    info(text: string) {
      this.stop();
      console.info(chalk.blue('i') + ' ' + text);
      return this;
    },
    render(frame: number) {
      const frameIndex = frame % this.frames.length;
      process.stdout.write(
        '\r' + 
        chalk.blue(this.frames[frameIndex]) + 
        ' ' + 
        this.text
      );
    },
  };
  
  return spinner.start(text);
};
</file>

<file path="src/utils/index.ts">
// Export all utilities
export * from './helpers';
export * from './logger';
export * from './errorReporter';
// Export other utility files here as we create them
</file>

<file path="src/utils/logger.ts">
import chalk from 'chalk';
import fs from 'fs';
import path from 'path';
import os from 'os';

// Define log levels
export enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR',
  FATAL = 'FATAL',
}

// Define log entry interface
export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  details?: Record<string, any>;
  stackTrace?: string;
}

// Logger configuration
interface LoggerConfig {
  logLevel: LogLevel;
  consoleOutput: boolean;
  fileOutput: boolean;
  logFilePath: string;
  maxLogFileSize: number; // in bytes
  maxLogFiles: number;
}

// Default configuration
const DEFAULT_CONFIG: LoggerConfig = {
  logLevel: LogLevel.INFO,
  consoleOutput: true,
  fileOutput: true,
  logFilePath: path.join(os.homedir(), '.sf-tui', 'logs', 'sf-tui.log'),
  maxLogFileSize: 5 * 1024 * 1024, // 5MB
  maxLogFiles: 5,
};

class Logger {
  private config: LoggerConfig = DEFAULT_CONFIG;
  private static instance: Logger;

  private constructor() {
    this.ensureLogDirectory();
  }

  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  // Configure the logger
  public configure(partialConfig: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...partialConfig };
    this.ensureLogDirectory();
  }

  // Ensure the log directory exists
  private ensureLogDirectory(): void {
    if (this.config.fileOutput) {
      const logDir = path.dirname(this.config.logFilePath);
      try {
        if (!fs.existsSync(logDir)) {
          fs.mkdirSync(logDir, { recursive: true });
        }
      } catch (error) {
        console.error(`Failed to create log directory: ${error}`);
        this.config.fileOutput = false;
      }
    }
  }

  // Check if we should rotate log files
  private checkLogRotation(): void {
    if (!this.config.fileOutput) return;

    try {
      if (fs.existsSync(this.config.logFilePath)) {
        const stats = fs.statSync(this.config.logFilePath);
        if (stats.size >= this.config.maxLogFileSize) {
          this.rotateLogFiles();
        }
      }
    } catch (error) {
      console.error(`Failed to check log rotation: ${error}`);
    }
  }

  // Rotate log files
  private rotateLogFiles(): void {
    try {
      // Remove oldest log file if we've reached the max number
      const oldestLog = `${this.config.logFilePath}.${this.config.maxLogFiles - 1}`;
      if (fs.existsSync(oldestLog)) {
        fs.unlinkSync(oldestLog);
      }

      // Shift all other log files
      for (let i = this.config.maxLogFiles - 2; i >= 0; i--) {
        const oldPath = i === 0 ? this.config.logFilePath : `${this.config.logFilePath}.${i}`;
        const newPath = `${this.config.logFilePath}.${i + 1}`;
        
        if (fs.existsSync(oldPath)) {
          fs.renameSync(oldPath, newPath);
        }
      }

      // Create a new empty log file
      fs.writeFileSync(this.config.logFilePath, '');
    } catch (error) {
      console.error(`Failed to rotate log files: ${error}`);
    }
  }

  // Format a log entry for output
  private formatLogEntry(entry: LogEntry): string {
    let formatted = `[${entry.timestamp}] [${entry.level}] ${entry.message}`;
    
    if (entry.details) {
      formatted += `\nDetails: ${JSON.stringify(entry.details, null, 2)}`;
    }
    
    if (entry.stackTrace) {
      formatted += `\nStack Trace: ${entry.stackTrace}`;
    }
    
    return formatted;
  }

  // Write a log entry to the console
  private writeToConsole(entry: LogEntry): void {
    if (!this.config.consoleOutput) return;

    let colorFn;
    switch (entry.level) {
      case LogLevel.DEBUG:
        colorFn = chalk.blue;
        break;
      case LogLevel.INFO:
        colorFn = chalk.white;
        break;
      case LogLevel.WARN:
        colorFn = chalk.yellow;
        break;
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        colorFn = chalk.red;
        break;
      default:
        colorFn = chalk.white;
    }

    console.log(colorFn(this.formatLogEntry(entry)));
  }

  // Write a log entry to the log file
  private writeToFile(entry: LogEntry): void {
    if (!this.config.fileOutput) return;

    this.checkLogRotation();

    try {
      const formattedEntry = this.formatLogEntry(entry) + '\n';
      fs.appendFileSync(this.config.logFilePath, formattedEntry);
    } catch (error) {
      console.error(`Failed to write to log file: ${error}`);
    }
  }

  // Create a log entry
  private createLogEntry(level: LogLevel, message: string, details?: Record<string, any>, error?: Error): LogEntry {
    const timestamp = new Date().toISOString();
    const stackTrace = error?.stack;
    
    return {
      timestamp,
      level,
      message,
      details,
      stackTrace,
    };
  }

  // Log a message if the log level permits
  private log(level: LogLevel, message: string, details?: Record<string, any>, error?: Error): void {
    const levelValue = Object.values(LogLevel).indexOf(level);
    const configLevelValue = Object.values(LogLevel).indexOf(this.config.logLevel);
    
    if (levelValue >= configLevelValue) {
      const entry = this.createLogEntry(level, message, details, error);
      this.writeToConsole(entry);
      this.writeToFile(entry);
    }
  }

  // Public logging methods
  public debug(message: string, details?: Record<string, any>): void {
    this.log(LogLevel.DEBUG, message, details);
  }

  public info(message: string, details?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, details);
  }

  public warn(message: string, details?: Record<string, any>, error?: Error): void {
    this.log(LogLevel.WARN, message, details, error);
  }

  public error(message: string, details?: Record<string, any>, error?: Error): void {
    this.log(LogLevel.ERROR, message, details, error);
  }

  public fatal(message: string, details?: Record<string, any>, error?: Error): void {
    this.log(LogLevel.FATAL, message, details, error);
  }

  // Log an error object directly
  public logError(error: Error, message?: string, details?: Record<string, any>): void {
    const errorMessage = message || error.message;
    this.error(errorMessage, details, error);
  }

  // Get the log file path
  public getLogFilePath(): string {
    return this.config.logFilePath;
  }

  // Clear the log file
  public clearLogs(): void {
    if (this.config.fileOutput && fs.existsSync(this.config.logFilePath)) {
      try {
        fs.writeFileSync(this.config.logFilePath, '');
      } catch (error) {
        console.error(`Failed to clear log file: ${error}`);
      }
    }
  }
}

// Export a singleton instance
export const logger = Logger.getInstance();

// Utility function to handle and log errors consistently
export function handleError(error: unknown, context?: string, details?: Record<string, any>): Error {
  const errorObject = error instanceof Error ? error : new Error(String(error));
  const contextMessage = context ? `[${context}] ${errorObject.message}` : errorObject.message;
  
  logger.error(contextMessage, details, errorObject);
  
  return errorObject;
}
</file>

<file path="src/index.ts">
#!/usr/bin/env node

import { run } from '@oclif/core';
import { logger, setupGlobalErrorHandlers } from './utils';

// Enable source map support for better error messages
import 'source-map-support/register';

// Set up global error handlers
setupGlobalErrorHandlers();

// Initialize logger and other services
logger.info('Starting SF TUI');

// Execute the CLI
// With ESModule support
run([import.meta.url])
  .then(() => {
    // Log successful completion
    logger.info('SF TUI completed successfully');
    // Exit with success code
    process.exit(0);
  })
  .catch((error) => {
    // Log the error using our logger
    logger.fatal('Error running SF TUI', { error });
    // Exit with error code
    process.exit(1);
  });
</file>

<file path="tests/utils/errorReporter.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { 
  errorReporter,
  ErrorSeverity,
  ErrorCategory,
  setupGlobalErrorHandlers
} from '../../src/utils/errorReporter';
import { logger } from '../../src/utils/logger';

// Mock logger
vi.mock('../../src/utils/logger', () => {
  return {
    logger: {
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      fatal: vi.fn(),
      log: vi.fn(),
    },
    LogLevel: {
      DEBUG: 'DEBUG',
      INFO: 'INFO',
      WARN: 'WARN',
      ERROR: 'ERROR',
      FATAL: 'FATAL',
    },
  };
});

describe('ErrorReporter', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    errorReporter.clearErrors();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should report errors', () => {
    const message = 'Test error';
    const error = new Error('Error details');
    
    const report = errorReporter.reportError(message, {
      error,
      severity: ErrorSeverity.HIGH,
      category: ErrorCategory.COMMAND,
      context: 'TestContext',
    });
    
    // Verify the report structure
    expect(report).toMatchObject({
      message,
      error,
      severity: ErrorSeverity.HIGH,
      category: ErrorCategory.COMMAND,
      context: 'TestContext',
      handled: false,
    });
    
    // Verify that ID and timestamp are generated
    expect(report.id).toBeDefined();
    expect(report.timestamp).toBeInstanceOf(Date);
    
    // Verify that logger was called
    expect(logger.log).toHaveBeenCalled();
    
    // Verify that the error was stored
    const storedErrors = errorReporter.getAllErrors();
    expect(storedErrors).toHaveLength(1);
    expect(storedErrors[0].id).toBe(report.id);
  });
  
  it('should report errors with error object as second parameter', () => {
    const message = 'Test error';
    const error = new Error('Error details');
    
    const report = errorReporter.reportError(message, error);
    
    // Verify the report structure
    expect(report).toMatchObject({
      message,
      error,
      severity: ErrorSeverity.MEDIUM, // Default
      category: ErrorCategory.UNKNOWN, // Default
      handled: false,
    });
    
    // Verify that logger was called
    expect(logger.log).toHaveBeenCalled();
  });

  it('should mark errors as handled', () => {
    const report = errorReporter.reportError('Test error');
    
    // Verify that error is initially not handled
    expect(report.handled).toBe(false);
    
    // Mark as handled
    errorReporter.markAsHandled(report.id);
    
    // Verify that error is now handled
    const storedError = errorReporter.getError(report.id);
    expect(storedError?.handled).toBe(true);
  });

  it('should clear all errors', () => {
    // Add some errors
    errorReporter.reportError('Error 1');
    errorReporter.reportError('Error 2');
    errorReporter.reportError('Error 3');
    
    // Verify errors were added
    expect(errorReporter.getAllErrors()).toHaveLength(3);
    
    // Clear errors
    errorReporter.clearErrors();
    
    // Verify errors were cleared
    expect(errorReporter.getAllErrors()).toHaveLength(0);
  });

  it('should get a specific error by ID', () => {
    const error1 = errorReporter.reportError('Error 1');
    const error2 = errorReporter.reportError('Error 2');
    
    // Get error by ID
    const retrievedError = errorReporter.getError(error1.id);
    
    // Verify the retrieved error
    expect(retrievedError).toBeDefined();
    expect(retrievedError?.id).toBe(error1.id);
    expect(retrievedError?.message).toBe('Error 1');
  });

  it('should handle subscriber notifications', () => {
    // Create a subscriber
    const subscriber = vi.fn();
    
    // Subscribe to errors
    const unsubscribe = errorReporter.subscribe(subscriber);
    
    // Report an error
    const report = errorReporter.reportError('Test error');
    
    // Verify subscriber was called
    expect(subscriber).toHaveBeenCalledWith(report);
    
    // Unsubscribe
    unsubscribe();
    
    // Report another error
    errorReporter.reportError('Another error');
    
    // Verify subscriber was not called again
    expect(subscriber).toHaveBeenCalledTimes(1);
  });

  it('should handle errors in subscribers', () => {
    // Create a subscriber that throws an error
    const subscriber = vi.fn().mockImplementation(() => {
      throw new Error('Subscriber error');
    });
    
    // Subscribe to errors
    errorReporter.subscribe(subscriber);
    
    // Report an error
    errorReporter.reportError('Test error');
    
    // Verify subscriber was called
    expect(subscriber).toHaveBeenCalled();
    
    // Verify error was logged
    expect(logger.error).toHaveBeenCalled();
  });

  it('should submit user feedback', () => {
    const report = errorReporter.reportError('Test error');
    
    // Submit feedback
    const feedback = {
      errorId: report.id,
      timestamp: new Date(),
      description: 'User feedback description',
      reproduce: 'Steps to reproduce',
      contact: 'user@example.com',
    };
    
    errorReporter.submitFeedback(feedback);
    
    // Verify that logger was called
    expect(logger.info).toHaveBeenCalledWith(
      expect.stringContaining('User feedback received'),
      expect.objectContaining({ feedback })
    );
  });

  describe('Helper methods for common error categories', () => {
    it('should report command errors', () => {
      const error = new Error('Command failed');
      const report = errorReporter.reportCommandError('Command error', error);
      
      expect(report.category).toBe(ErrorCategory.COMMAND);
      expect(report.severity).toBe(ErrorSeverity.MEDIUM);
      expect(report.userAction).toBeDefined();
    });
    
    it('should report network errors', () => {
      const error = new Error('Network failed');
      const report = errorReporter.reportNetworkError('Network error', error);
      
      expect(report.category).toBe(ErrorCategory.NETWORK);
      expect(report.severity).toBe(ErrorSeverity.MEDIUM);
      expect(report.userAction).toBeDefined();
    });
    
    it('should report auth errors', () => {
      const error = new Error('Auth failed');
      const report = errorReporter.reportAuthError('Auth error', error);
      
      expect(report.category).toBe(ErrorCategory.AUTH);
      expect(report.severity).toBe(ErrorSeverity.HIGH);
      expect(report.userAction).toBeDefined();
    });
    
    it('should report validation errors', () => {
      const error = new Error('Validation failed');
      const report = errorReporter.reportValidationError('Validation error', error);
      
      expect(report.category).toBe(ErrorCategory.VALIDATION);
      expect(report.severity).toBe(ErrorSeverity.LOW);
      expect(report.userAction).toBeDefined();
    });
  });
});

describe('setupGlobalErrorHandlers', () => {
  const originalProcessOn = process.on;
  const originalProcessExit = process.exit;
  
  beforeEach(() => {
    // Mock process.on and process.exit
    process.on = vi.fn() as any;
    process.exit = vi.fn() as any;
    
    // Reset error reporter
    errorReporter.clearErrors();
    
    // Clear all mocks
    vi.clearAllMocks();
  });
  
  afterEach(() => {
    // Restore original process methods
    process.on = originalProcessOn;
    process.exit = originalProcessExit;
  });
  
  it('should set up handlers for uncaught exceptions', () => {
    setupGlobalErrorHandlers();
    
    // Verify process.on was called for uncaught exceptions
    expect(process.on).toHaveBeenCalledWith(
      'uncaughtException',
      expect.any(Function)
    );
    
    // Simulate an uncaught exception
    const handler = (process.on as any).mock.calls.find(
      call => call[0] === 'uncaughtException'
    )[1];
    
    const error = new Error('Uncaught error');
    handler(error);
    
    // Verify that error was reported
    const errors = errorReporter.getAllErrors();
    expect(errors).toHaveLength(1);
    expect(errors[0].severity).toBe(ErrorSeverity.CRITICAL);
    
    // Verify process.exit was called
    expect(process.exit).toHaveBeenCalledWith(1);
  });
  
  it('should set up handlers for unhandled promise rejections', () => {
    setupGlobalErrorHandlers();
    
    // Verify process.on was called for unhandled rejections
    expect(process.on).toHaveBeenCalledWith(
      'unhandledRejection',
      expect.any(Function)
    );
    
    // Simulate an unhandled rejection
    const handler = (process.on as any).mock.calls.find(
      call => call[0] === 'unhandledRejection'
    )[1];
    
    const error = new Error('Unhandled rejection');
    handler(error, Promise.resolve()); // Second param is the promise
    
    // Verify that error was reported
    const errors = errorReporter.getAllErrors();
    expect(errors).toHaveLength(1);
    expect(errors[0].severity).toBe(ErrorSeverity.HIGH);
    
    // Verify process.exit was NOT called (we don't exit for unhandled rejections)
    expect(process.exit).not.toHaveBeenCalled();
  });
  
  it('should handle non-Error rejections', () => {
    setupGlobalErrorHandlers();
    
    // Get the unhandled rejection handler
    const handler = (process.on as any).mock.calls.find(
      call => call[0] === 'unhandledRejection'
    )[1];
    
    // Simulate a non-Error rejection (string)
    handler('String rejection reason', Promise.resolve());
    
    // Verify that error was reported and converted to Error
    const errors = errorReporter.getAllErrors();
    expect(errors).toHaveLength(1);
    expect(errors[0].error).toBeInstanceOf(Error);
    expect(errors[0].error?.message).toBe('String rejection reason');
  });
});
</file>

<file path="tests/utils/logger.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { logger, LogLevel } from '../../src/utils/logger';

// Mock fs module
vi.mock('fs', () => ({
  existsSync: vi.fn(),
  statSync: vi.fn(),
  mkdirSync: vi.fn(),
  appendFileSync: vi.fn(),
  writeFileSync: vi.fn(),
  unlinkSync: vi.fn(),
  renameSync: vi.fn(),
}));

// Mock console
vi.spyOn(console, 'log').mockImplementation(() => {});
vi.spyOn(console, 'error').mockImplementation(() => {});
vi.spyOn(console, 'warn').mockImplementation(() => {});
vi.spyOn(console, 'info').mockImplementation(() => {});

describe('Logger', () => {
  const tempLogPath = path.join(os.tmpdir(), 'sf-tui-test.log');
  
  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks();
    
    // Configure logger to use test file
    logger.configure({
      logLevel: LogLevel.DEBUG,
      logFilePath: tempLogPath,
      consoleOutput: true,
      fileOutput: true,
    });
    
    // Mock fs.existsSync to return true for log directory
    (fs.existsSync as any).mockImplementation((path: string) => {
      if (path === tempLogPath) return false;
      return true;
    });
  });
  
  afterEach(() => {
    vi.resetAllMocks();
  });
  
  it('should create log directory if it does not exist', () => {
    // Mock fs.existsSync to return false for log directory
    (fs.existsSync as any).mockReturnValueOnce(false);
    
    // Configure logger
    logger.configure({
      logFilePath: tempLogPath,
    });
    
    // Verify mkdirSync was called
    expect(fs.mkdirSync).toHaveBeenCalled();
  });
  
  it('should log debug messages', () => {
    const message = 'Debug message';
    logger.debug(message);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining(message),
    );
  });
  
  it('should log info messages', () => {
    const message = 'Info message';
    logger.info(message);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining(message),
    );
  });
  
  it('should log warning messages', () => {
    const message = 'Warning message';
    logger.warn(message);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining(message),
    );
  });
  
  it('should log error messages', () => {
    const message = 'Error message';
    logger.error(message);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining(message),
    );
  });
  
  it('should log fatal messages', () => {
    const message = 'Fatal message';
    logger.fatal(message);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining(message),
    );
  });
  
  it('should include error stack trace in logs', () => {
    const message = 'Error with stack trace';
    const error = new Error('Test error');
    logger.error(message, {}, error);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called with error stack
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining('Stack Trace'),
    );
  });
  
  it('should include details in logs', () => {
    const message = 'Message with details';
    const details = { key: 'value', count: 42 };
    logger.info(message, details);
    
    // Verify console.log was called
    expect(console.log).toHaveBeenCalled();
    
    // Verify appendFileSync was called with details
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      tempLogPath,
      expect.stringContaining('Details'),
    );
  });
  
  it('should not log messages below configured level', () => {
    // Configure logger to only log ERROR and higher
    logger.configure({
      logLevel: LogLevel.ERROR,
    });
    
    logger.debug('Debug message');
    logger.info('Info message');
    logger.warn('Warning message');
    
    // Verify console.log was not called for these levels
    expect(console.log).not.toHaveBeenCalled();
    expect(fs.appendFileSync).not.toHaveBeenCalled();
    
    // Verify that ERROR level is still logged
    logger.error('Error message');
    expect(console.log).toHaveBeenCalled();
    expect(fs.appendFileSync).toHaveBeenCalled();
  });
  
  it('should check log rotation when writing to file', () => {
    // Mock fs.existsSync and fs.statSync for log rotation
    (fs.existsSync as any).mockReturnValueOnce(true);
    (fs.statSync as any).mockReturnValueOnce({ size: 10 * 1024 * 1024 }); // 10MB
    
    logger.configure({
      maxLogFileSize: 5 * 1024 * 1024, // 5MB
    });
    
    logger.info('Log message');
    
    // Verify that log rotation was attempted
    expect(fs.existsSync).toHaveBeenCalledWith(tempLogPath);
    expect(fs.statSync).toHaveBeenCalledWith(tempLogPath);
  });
  
  it('should rotate logs when file size exceeds max size', () => {
    // Mock fs.existsSync and fs.statSync for log rotation
    (fs.existsSync as any).mockReturnValueOnce(true);
    (fs.statSync as any).mockReturnValueOnce({ size: 10 * 1024 * 1024 }); // 10MB
    
    logger.configure({
      maxLogFileSize: 5 * 1024 * 1024, // 5MB
      maxLogFiles: 3,
    });
    
    logger.info('Log message');
    
    // Verify that log rotation was performed
    expect(fs.renameSync).toHaveBeenCalled();
    expect(fs.writeFileSync).toHaveBeenCalledWith(tempLogPath, '');
  });
  
  it('should clear logs when requested', () => {
    // Mock fs.existsSync for clearLogs
    (fs.existsSync as any).mockReturnValueOnce(true);
    
    logger.clearLogs();
    
    // Verify that writeFileSync was called to clear the log file
    expect(fs.writeFileSync).toHaveBeenCalledWith(tempLogPath, '');
  });
  
  it('should handle errors when creating log directory', () => {
    // Mock fs.existsSync to return false for log directory
    (fs.existsSync as any).mockReturnValueOnce(false);
    
    // Mock fs.mkdirSync to throw an error
    (fs.mkdirSync as any).mockImplementationOnce(() => {
      throw new Error('Cannot create directory');
    });
    
    // Configure logger
    logger.configure({
      logFilePath: tempLogPath,
    });
    
    // Verify console.error was called
    expect(console.error).toHaveBeenCalled();
    
    // Log a message, should not try to write to file
    logger.info('Test message');
    
    // Verify appendFileSync was not called
    expect(fs.appendFileSync).not.toHaveBeenCalled();
  });
  
  it('should handle errors when writing to log file', () => {
    // Mock fs.appendFileSync to throw an error
    (fs.appendFileSync as any).mockImplementationOnce(() => {
      throw new Error('Cannot write to file');
    });
    
    // Log a message
    logger.info('Test message');
    
    // Verify console.error was called
    expect(console.error).toHaveBeenCalled();
  });
});

describe('handleError utility function', () => {
  it('should log errors and return an Error object', () => {
    const { handleError } = require('../../src/utils/logger');
    const error = new Error('Test error');
    const context = 'TestContext';
    const details = { key: 'value' };
    
    // Spy on logger.error
    const errorSpy = vi.spyOn(logger, 'error');
    
    // Call handleError
    const result = handleError(error, context, details);
    
    // Verify logger.error was called with correct arguments
    expect(errorSpy).toHaveBeenCalledWith(
      '[TestContext] Test error',
      details,
      error
    );
    
    // Verify that an Error object was returned
    expect(result).toBeInstanceOf(Error);
    expect(result.message).toBe('Test error');
  });
  
  it('should convert non-Error objects to Error objects', () => {
    const { handleError } = require('../../src/utils/logger');
    const errorMessage = 'This is a string error';
    
    // Spy on logger.error
    const errorSpy = vi.spyOn(logger, 'error');
    
    // Call handleError with a string
    const result = handleError(errorMessage);
    
    // Verify logger.error was called
    expect(errorSpy).toHaveBeenCalled();
    
    // Verify that an Error object was returned
    expect(result).toBeInstanceOf(Error);
    expect(result.message).toBe(errorMessage);
  });
});
</file>

<file path=".gitignore">
404: Not Found
# Additional common ignores
.DS_Store
*.log
.env
node_modules/
.idea/
.vscode/
*.swp
*.swo
tmp/
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# SF TUI - Project Overview & Development Guide

## Project Description
SF TUI is a modern, interactive terminal-based interface for Salesforce development. It provides a user-friendly way to interact with Salesforce CLI commands, making it easier for developers and admins to manage their Salesforce orgs and projects without memorizing complex CLI commands.

## Key Components

### Core Features
- **Org Management**: Connect to and manage multiple Salesforce orgs
- **Project Tools**: Create and manage Salesforce projects
- **Authentication**: Secure org authentication flows
- **Metadata Operations**: Deploy and retrieve metadata
- **Development Tools**: Execute Apex, Flows, and more
- **Plugin Management**: View and manage CLI plugins

### Technical Stack
- **Language**: TypeScript
- **UI Framework**: Ink (React for CLIs)
- **CLI Framework**: oclif
- **Build Tool**: tsup
- **Testing**: Vitest
- **Linting/Formatting**: ESLint & Prettier

## Project Structure
- `src/`: Main source code
  - `commands/`: CLI command implementations
  - `components/`: Reusable UI components
  - `themes/`: Styling and theming
  - `hooks/`: Custom React hooks
  - `utils/`: Utility functions

## Development Commands

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Run in development mode with hot-reloading
npm run dev

# Run tests
npm test

# Run tests in watch mode
npm test:watch

# Run linting
npm run lint

# Format code with Prettier
npm run format
```

## Development Plan

### Phase 1: Setup & Foundation (Priority: High)
1. **Fix TypeScript and Dependency Issues**
   ```bash
   # Install missing type definitions
   npm install --save-dev @types/execa @types/react @types/react-dom @types/node
   ```
   - Fix TextInput component references in MetadataTools, RunTools, and PluginsPanel
   - Resolve any type errors in the codebase

2. **Implement Basic Component Infrastructure**
   - Complete common component implementations (TextInput, Button, etc.)
   - Ensure proper theming support across all components

### Phase 2: Core Features Implementation (Priority: High)
1. **Complete Org Manager**
   - Fix org deletion implementation (currently just a placeholder)
   - Add refresh capability for org list
   - Implement error handling for failed operations

2. **Enhance Metadata Tools**
   - Replace dummy data with actual org loading
   - Implement progress tracking for long-running operations
   - Add validation for input fields

3. **Improve Run Tools**
   - Complete Apex execution implementation
   - Add proper Flow execution support
   - Implement SOQL query results visualization

4. **Enhance Plugin Management**
   - Complete plugin installation, update, and removal functionality
   - Add plugin search capability
   - Improve error handling for plugin operations

### Phase 3: Testing & Documentation (Priority: Medium)
1. **Testing Infrastructure**
   - Set up component testing with Vitest
   - Configure test coverage reporting
   ```bash
   # Run tests with coverage
   npm test -- --coverage
   ```
   - Add integration tests for CLI commands

2. **Documentation**
   - Add JSDoc comments to all components and utilities
   - Update README with comprehensive setup instructions
   - Create contribution guidelines
   - Document common patterns and best practices

### Phase 4: Finalization & Distribution (Priority: Low)
1. **CI/CD Setup**
   - Configure GitHub Actions workflow
   - Set up automated testing
   - Configure release process

2. **Performance Optimization**
   - Analyze and improve component rendering performance
   - Optimize CLI command execution
   - Add caching for frequently accessed data

3. **User Experience Enhancements**
   - Implement keyboard shortcuts
   - Add onboarding/help screens
   - Create a dark mode theme

## Coding Guidelines

1. **Component Structure**
   - Use functional components with hooks
   - Keep components focused on a single responsibility
   - Extract reusable logic into custom hooks

2. **Error Handling**
   - Always provide meaningful error messages
   - Use try/catch blocks for async operations
   - Implement user-friendly error displays

3. **Styling Conventions**
   - Use the theme system for all styling
   - Follow the Salesforce Lightning Design System color palette
   - Maintain consistent spacing and layout

4. **Performance Considerations**
   - Minimize rerenders with React.memo and useMemo where appropriate
   - Keep terminal UI responsive by avoiding blocking operations
   - Use async/await for all file system and network operations

## Technical Requirements
- Node.js 18 or later
- npm 9 or later
- Salesforce CLI (sf) installed and configured

## Architecture

The application follows a component-based architecture using React with Ink for terminal rendering:
- **Entry point**: `src/index.ts` - Initializes the CLI application
- **Commands**: `src/commands/` - CLI command implementations
- **Components**:
  - `common/`: Reusable UI components
  - `org/`: Org management components
  - `project/`: Project tools
  - `auth/`: Authentication flows
  - `metadata/`: Metadata operations
  - `run/`: Code execution tools
  - `plugins/`: Plugin management
</file>

<file path="package.json">
{
  "name": "sf-tui",
  "version": "0.1.0",
  "description": "A modern, interactive terminal UI for Salesforce CLI",
  "main": "dist/index.js",
  "bin": {
    "sft": "./bin/run"
  },
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "test": "vitest",
    "test:watch": "vitest watch",
    "lint": "eslint . --ext .ts",
    "prepack": "rm -rf dist && npm run build",
    "version": "git add -A src",
    "postversion": "git push && git push --tags"
  },
  "dependencies": {
    "@oclif/core": "^3.0.0",
    "chalk": "^5.0.0",
    "execa": "^8.0.0",
    "ink": "^4.4.0",
    "ink-box": "^2.0.0",
    "ink-select-input": "^5.0.0",
    "ink-spinner": "^4.0.0",
    "ink-text-input": "^5.0.0",
    "inquirer": "^9.0.0",
    "open": "^9.0.0",
    "ora": "^7.0.0",
    "react": "^18.0.0",
    "react-reconciler": "^0.29.0",
    "yoga-layout-prebuilt": "^1.10.0"
  },
  "devDependencies": {
    "@types/chai": "^4.3.0",
    "@types/execa": "^0.9.0",
    "@types/mocha": "^10.0.0",
    "@types/node": "^20.17.48",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@types/react-reconciler": "^0.18.0",
    "@types/resize-observer-browser": "^0.1.11",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-react": "^7.30.0",
    "prettier": "^3.0.0",
    "tsup": "^8.0.0",
    "typescript": "^5.0.0",
    "vitest": "^1.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "oclif": {
    "commands": "./dist/commands",
    "bin": "sft"
  },
  "type": "module"
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "declaration": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "types": ["node", "vitest/globals", "resize-observer-browser"],
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "noImplicitAny": false,
    "ignoreDeprecations": "5.0"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="tsup.config.ts">
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  bundle: true,
  minify: true,
  target: 'node18',
  platform: 'node',
  outDir: 'dist',
  external: ['react'],
  noExternal: [],
  esbuildOptions(options) {
    options.jsx = 'automatic';
  },
  loader: {
    '.tsx': 'tsx',
    '.ts': 'ts',
  },
});
</file>

<file path="README.md">
# SF TUI - Salesforce Terminal UI

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A modern, interactive terminal-based interface for Salesforce development. SF TUI provides a user-friendly way to interact with Salesforce CLI commands, making it easier for developers and admins to manage their Salesforce orgs and projects without memorizing complex CLI commands.

![SF TUI Demo](https://raw.githubusercontent.com/yourusername/sf-tui/main/docs/demo.gif)

## ✨ Features

- 🏢 **Org Management**: List, connect, and manage your Salesforce orgs
- 🚀 **Project Tools**: Create and manage Salesforce projects and packages
- 🔐 **Authentication**: Easily authenticate with your orgs
- 🏷️ **Alias Management**: Manage your Salesforce CLI aliases
- 📦 **Metadata Tools**: Deploy, retrieve, and manage metadata
- ⚡ **Run Tools**: Execute Apex, Flows, and more
- 🧩 **Plugin Management**: View and manage your CLI plugins

## 🚀 Getting Started

### Prerequisites

- Node.js 18 or later
- npm 9 or later
- Salesforce CLI (sf) installed and configured

### Installation

```bash
# Install globally
npm install -g sf-tui

# Or install locally in a project
npm install --save-dev sf-tui
```

If installing from source:

```bash
# Clone the repository
git clone https://github.com/yourusername/sf-tui.git
cd sf-tui

# Install dependencies
npm install

# Link the package globally
npm link
```

### Usage

```bash
# Start the TUI
sft

# Show help
sft --help

# Show version
sft --version
```

## 🖥️ Screenshots

### Main Menu
![Main Menu](https://raw.githubusercontent.com/yourusername/sf-tui/main/docs/main-menu.png)

### Org Management
![Org Management](https://raw.githubusercontent.com/yourusername/sf-tui/main/docs/org-management.png)

### Metadata Tools
![Metadata Tools](https://raw.githubusercontent.com/yourusername/sf-tui/main/docs/metadata-tools.png)

## 🛠 Development

### Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/sf-tui.git
cd sf-tui

# Install dependencies
npm install

# Fix TypeScript type definitions (if needed)
npm install --save-dev @types/execa @types/react @types/react-dom @types/node
```

### Available Scripts

- `npm run build` - Build the project
- `npm run dev` - Run in development mode with hot-reloading
- `npm test` - Run tests
- `npm run test:watch` - Run tests in watch mode
- `npm run lint` - Run ESLint

### Project Structure

- `src/`: Main source code
  - `commands/`: CLI command implementations
  - `components/`: Reusable UI components
    - `common/`: Shared UI components
    - `org/`: Org management components
    - `project/`: Project tools
    - `auth/`: Authentication flows
    - `metadata/`: Metadata operations
    - `run/`: Code execution tools
    - `plugins/`: Plugin management
  - `themes/`: Styling and theming
  - `hooks/`: Custom React hooks
  - `utils/`: Utility functions
  - `types/`: TypeScript type definitions

## 🧩 Tech Stack

- **Language**: TypeScript
- **UI Framework**: [Ink](https://github.com/vadimdemedes/ink) (React for CLIs)
- **CLI Framework**: [oclif](https://oclif.io/)
- **Build Tool**: [tsup](https://github.com/egoist/tsup)
- **Testing**: [Vitest](https://vitest.dev/)

## 📝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add some amazing feature'`
4. Push to the branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- Built with [oclif](https://oclif.io/), [Ink](https://github.com/vadimdemedes/ink), and TypeScript
- Inspired by tools like [gh](https://cli.github.com/) and [lazydocker](https://github.com/jesseduffield/lazydocker)

---

Made with ❤️ for the Salesforce community
</file>

</files>
